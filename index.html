<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1" />
  <title>Classical Melody Keyboard</title>
  <style>
    :root {
      color-scheme: light;
      --bg: #f3f1ff;
      --panel: #ffffff;
      --text: #1d1b2f;
      --accent-1: #ff9f1c;
      --accent-2: #ff595e;
      --accent-3: #8ac926;
      --accent-4: #1982c4;
      --accent-5: #6a4c93;
      --accent-6: #ffca3a;
      --toast-accent: var(--accent-4);
    }

    * {
      box-sizing: border-box;
    }

    body {
      margin: 0;
      font-family: 'Nunito', 'Helvetica Neue', Arial, sans-serif;
      background: radial-gradient(circle at top, #ffffff 0%, var(--bg) 60%, #e2ddff 100%);
      color: var(--text);
      min-height: 100vh;
      display: flex;
      align-items: center;
      justify-content: center;
      padding: 2rem 1.5rem 3rem;
    }

    main {
      max-width: 1040px;
      width: 100%;
      background: var(--panel);
      border-radius: 24px;
      box-shadow: 0 20px 60px rgba(40, 24, 80, 0.25);
      padding: 2.5rem 2rem 2.75rem;
      position: relative;
      overflow: hidden;
    }

    main::after {
      content: "";
      position: absolute;
      inset: -120px -160px auto auto;
      width: 280px;
      height: 280px;
      background: linear-gradient(135deg, rgba(255, 153, 0, 0.4), rgba(25, 130, 196, 0.35));
      border-radius: 50%;
      z-index: 0;
      filter: blur(0.5px);
    }

    header {
      position: relative;
      z-index: 1;
      text-align: center;
      margin-bottom: 2.5rem;
    }

    h1 {
      margin: 0 0 0.75rem;
      font-size: clamp(2.1rem, 4vw, 2.8rem);
    }

    p.lead {
      margin: 0 auto;
      max-width: 640px;
      font-size: 1.1rem;
      line-height: 1.6;
    }

    .now-playing {
      margin: 1.75rem auto 0;
      max-width: 680px;
      background: rgba(255, 255, 255, 0.75);
      border-radius: 16px;
      padding: 0.85rem 1.2rem;
      display: flex;
      flex-wrap: wrap;
      justify-content: center;
      align-items: center;
      gap: 0.5rem;
      font-size: 1rem;
      box-shadow: 0 8px 24px rgba(30, 30, 60, 0.12);
    }

    .now-playing .label {
      font-weight: 700;
      text-transform: uppercase;
      letter-spacing: 0.08em;
      font-size: 0.85rem;
      color: rgba(29, 27, 47, 0.7);
    }

    .now-playing .value {
      font-weight: 600;
    }

    .keys-grid {
      position: relative;
      z-index: 1;
      display: flex;
      flex-direction: column;
      gap: 1.5rem;
    }

    .keys-row-wrapper {
      display: flex;
      flex-direction: column;
      gap: 0.65rem;
    }

    .keys-row-label {
      font-size: 0.8rem;
      font-weight: 700;
      letter-spacing: 0.08em;
      text-transform: uppercase;
      color: rgba(29, 27, 47, 0.55);
      padding-left: 0.35rem;
    }

    .keys-row {
      display: grid;
      grid-auto-flow: column;
      grid-auto-columns: minmax(115px, 1fr);
      gap: 1rem;
      padding-bottom: 0.4rem;
      overflow-x: auto;
      scroll-snap-type: x mandatory;
    }

    .keys-row::-webkit-scrollbar {
      height: 8px;
    }

    .keys-row::-webkit-scrollbar-thumb {
      background: rgba(106, 76, 147, 0.22);
      border-radius: 999px;
    }

    .keys-row:focus-visible {
      outline: 2px solid var(--accent-4);
      outline-offset: 4px;
    }

    .key-card {
      background: rgba(255, 255, 255, 0.9);
      border-radius: 18px;
      padding: 1.4rem 1.1rem 2rem;
      display: flex;
      flex-direction: column;
      align-items: center;
      justify-content: center;
      text-align: center;
      cursor: pointer;
      box-shadow: 0 10px 24px rgba(30, 30, 60, 0.18);
      transition: transform 0.2s ease, box-shadow 0.2s ease, background 0.2s ease;
      border: 3px solid transparent;
      position: relative;
      --card-color: var(--accent-4);
      scroll-snap-align: start;
    }

    .key-card span.letter {
      font-size: clamp(2.1rem, 5vw, 3rem);
      font-weight: 800;
      letter-spacing: 0.05em;
      margin-bottom: 0.55rem;
      display: inline-flex;
      flex-wrap: wrap;
      width: 68px;
      height: 68px;
      border-radius: 18px;
      align-items: center;
      justify-content: center;
      line-height: 1.1;
      text-align: center;
      white-space: normal;
      color: white;
    }

    .key-card span.title {
      font-size: 1rem;
      font-weight: 600;
      line-height: 1.4;
    }

    .key-card span.subtitle {
      display: block;
      margin-top: 0.25rem;
      font-size: 0.9rem;
      opacity: 0.7;
    }

    .key-card .progress-track {
      position: absolute;
      left: 18px;
      right: 18px;
      bottom: 14px;
      height: 8px;
      border-radius: 999px;
      background: rgba(255, 255, 255, 0.7);
      overflow: hidden;
      opacity: 0;
      transform: translateY(6px);
      transition: opacity 0.3s ease, transform 0.3s ease;
    }

    .key-card .progress-bar {
      width: 0%;
      height: 100%;
      background: var(--card-color);
      border-radius: inherit;
    }

    .key-card[data-active="true"] .progress-track {
      opacity: 1;
      transform: translateY(0);
    }

    .key-card[data-active="true"] {
      transform: translateY(-6px) scale(1.02);
      box-shadow: 0 16px 32px rgba(30, 30, 60, 0.25);
      border-color: rgba(106, 76, 147, 0.6);
    }

    .key-card[data-queued="true"] {
      border-color: rgba(106, 76, 147, 0.35);
      box-shadow: 0 12px 26px rgba(30, 30, 60, 0.18);
    }

    .key-card[data-queued="true"]::after {
      content: 'Next';
      position: absolute;
      top: 10px;
      right: 10px;
      background: rgba(106, 76, 147, 0.16);
      color: var(--text);
      font-size: 0.65rem;
      font-weight: 700;
      letter-spacing: 0.08em;
      text-transform: uppercase;
      padding: 0.3rem 0.55rem;
      border-radius: 999px;
    }

    .key-card:active {
      transform: translateY(2px) scale(0.99);
    }

    .controls {
      margin-top: 2.5rem;
      position: relative;
      z-index: 1;
      display: flex;
      flex-wrap: wrap;
      justify-content: space-between;
      align-items: center;
      gap: 1.5rem;
      background: rgba(255, 255, 255, 0.8);
      border-radius: 16px;
      padding: 1.1rem 1.4rem;
      box-shadow: 0 12px 26px rgba(30, 30, 60, 0.15);
    }

    .volume-control {
      display: flex;
      flex-wrap: wrap;
      align-items: center;
      gap: 0.75rem;
      min-width: 220px;
    }

    .volume-control label {
      font-weight: 700;
      letter-spacing: 0.05em;
      text-transform: uppercase;
      font-size: 0.75rem;
      color: rgba(29, 27, 47, 0.65);
    }

    .volume-control input[type="range"] {
      -webkit-appearance: none;
      appearance: none;
      width: clamp(160px, 25vw, 260px);
      height: 6px;
      border-radius: 999px;
      background: rgba(106, 76, 147, 0.24);
      outline: none;
      position: relative;
    }

    .volume-control input[type="range"]::-webkit-slider-thumb {
      -webkit-appearance: none;
      appearance: none;
      width: 18px;
      height: 18px;
      border-radius: 50%;
      background: var(--accent-4);
      cursor: pointer;
      box-shadow: 0 4px 10px rgba(25, 130, 196, 0.35);
    }

    .volume-control input[type="range"]::-moz-range-thumb {
      width: 18px;
      height: 18px;
      border-radius: 50%;
      background: var(--accent-4);
      cursor: pointer;
      box-shadow: 0 4px 10px rgba(25, 130, 196, 0.35);
      border: none;
    }

    .volume-control__value {
      font-weight: 600;
      font-size: 0.9rem;
      min-width: 3.25rem;
    }

    .stop {
      margin-left: auto;
    }

    .queue-panel {
      margin-top: 2.5rem;
      position: relative;
      z-index: 1;
      background: rgba(255, 255, 255, 0.85);
      border-radius: 18px;
      padding: 1.4rem 1.6rem;
      box-shadow: 0 12px 28px rgba(30, 30, 60, 0.16);
      display: flex;
      flex-direction: column;
      gap: 0.9rem;
    }

    .queue-panel__header {
      display: flex;
      align-items: center;
      justify-content: space-between;
      gap: 1rem;
    }

    .queue-panel h2 {
      margin: 0;
      font-size: 1.2rem;
    }

    .queue-empty {
      margin: 0;
      font-size: 0.95rem;
      color: rgba(29, 27, 47, 0.65);
    }

    .queue-summary {
      margin: 0;
      font-size: 0.9rem;
      color: rgba(29, 27, 47, 0.7);
      display: flex;
      gap: 0.4rem;
      align-items: baseline;
      flex-wrap: wrap;
    }

    .queue-summary__pill {
      display: inline-flex;
      align-items: center;
      justify-content: center;
      padding: 0.2rem 0.65rem;
      border-radius: 999px;
      background: rgba(25, 130, 196, 0.12);
      font-weight: 600;
      letter-spacing: 0.04em;
      text-transform: uppercase;
      font-size: 0.7rem;
      color: rgba(29, 27, 47, 0.75);
    }

    .queue-summary__text {
      font-weight: 600;
    }

    .queue-list {
      list-style: none;
      margin: 0;
      padding: 0;
      display: flex;
      flex-direction: column;
      gap: 0.6rem;
    }

    .queue-item {
      display: flex;
      align-items: center;
      gap: 0.65rem;
      font-size: 0.95rem;
      color: rgba(29, 27, 47, 0.9);
    }

    .queue-item .queue-pill {
      display: inline-flex;
      align-items: center;
      justify-content: center;
      background: rgba(106, 76, 147, 0.14);
      color: var(--text);
      border-radius: 999px;
      padding: 0.35rem 0.75rem;
      font-weight: 600;
      letter-spacing: 0.01em;
    }

    .queue-item .queue-meta {
      font-size: 0.8rem;
      text-transform: uppercase;
      letter-spacing: 0.08em;
      color: rgba(29, 27, 47, 0.6);
    }

    .queue-item.queue-item--more {
      justify-content: flex-end;
      font-style: italic;
      color: rgba(29, 27, 47, 0.6);
    }

    .queue-item.is-playing .queue-pill {
      background: rgba(25, 130, 196, 0.16);
      color: var(--accent-4);
    }

    .queue-item.is-next .queue-pill {
      background: rgba(255, 159, 28, 0.18);
      color: var(--accent-1);
    }

    button.clear-queue {
      background: transparent;
      border: 2px solid rgba(106, 76, 147, 0.3);
      color: var(--text);
      font-weight: 600;
      border-radius: 999px;
      padding: 0.45rem 1.1rem;
      cursor: pointer;
      transition: border-color 0.2s ease, transform 0.2s ease;
    }

    button.clear-queue:hover:not(:disabled) {
      border-color: rgba(106, 76, 147, 0.65);
      transform: translateY(-2px);
    }

    button.clear-queue:disabled {
      cursor: not-allowed;
      opacity: 0.6;
    }

    button.stop {
      background: var(--accent-4);
      color: #fff;
      font-weight: 700;
      font-size: 1.05rem;
      border: none;
      border-radius: 999px;
      padding: 0.9rem 2.4rem;
      cursor: pointer;
      box-shadow: 0 14px 28px rgba(25, 130, 196, 0.35);
      transition: transform 0.2s ease, box-shadow 0.2s ease, filter 0.2s ease;
    }

    button.stop:hover {
      transform: translateY(-3px);
      box-shadow: 0 18px 36px rgba(25, 130, 196, 0.35);
      filter: brightness(1.05);
    }

    button.stop:active {
      transform: translateY(1px);
    }

    footer {
      margin-top: 2rem;
      text-align: center;
      font-size: 0.9rem;
      color: rgba(29, 27, 47, 0.7);
      position: relative;
      z-index: 1;
    }

    .melody-toast {
      position: fixed;
      bottom: 32px;
      right: 32px;
      z-index: 5;
      pointer-events: none;
      opacity: 0;
      transform: translateY(16px);
      transition: opacity 0.25s ease, transform 0.25s ease;
      max-width: min(320px, calc(100vw - 40px));
    }

    .melody-toast[data-visible="true"] {
      opacity: 1;
      transform: translateY(0);
    }

    .melody-toast__bubble {
      display: flex;
      align-items: center;
      gap: 0.85rem;
      background: rgba(255, 255, 255, 0.92);
      border-radius: 22px;
      padding: 0.75rem 1.1rem;
      box-shadow: 0 18px 40px rgba(30, 30, 60, 0.2);
      border: 2px solid rgba(106, 76, 147, 0.25);
      backdrop-filter: blur(8px);
    }

    .melody-toast__key {
      display: inline-flex;
      align-items: center;
      justify-content: center;
      min-width: 48px;
      min-height: 48px;
      padding: 0 0.75rem;
      border-radius: 14px;
      background: var(--toast-accent);
      color: #fff;
      font-weight: 800;
      font-size: 1.4rem;
      letter-spacing: 0.04em;
      white-space: nowrap;
      text-align: center;
    }

    .melody-toast__text {
      display: flex;
      flex-direction: column;
      gap: 0.2rem;
    }

    .melody-toast__title {
      font-weight: 700;
      font-size: 1.05rem;
      color: var(--text);
      line-height: 1.2;
    }

    .melody-toast__composer {
      font-size: 0.85rem;
      letter-spacing: 0.04em;
      text-transform: uppercase;
      color: rgba(29, 27, 47, 0.65);
    }

    @media (max-width: 600px) {
      main {
        padding: 2rem 1.4rem;
      }

      .keys-grid {
        gap: 1.1rem;
      }

      .keys-row {
        grid-auto-columns: minmax(140px, 70%);
      }

      .key-card {
        padding: 1.1rem 0.85rem 1.7rem;
      }

      .now-playing {
        padding: 0.75rem 1rem;
        font-size: 0.95rem;
      }

      .key-card span.letter {
        width: 60px;
        height: 60px;
        font-size: 2.2rem;
      }

      .queue-panel {
        padding: 1.1rem 1.2rem;
      }

      .queue-panel__header {
        flex-direction: column;
        align-items: flex-start;
        gap: 0.75rem;
      }

      .melody-toast {
        left: 20px;
        right: 20px;
        bottom: 24px;
        max-width: none;
      }

      .melody-toast__bubble {
        justify-content: center;
        text-align: center;
      }

      .melody-toast__key {
        min-width: 44px;
        min-height: 44px;
        font-size: 1.2rem;
      }
    }
  </style>
</head>
<body>
  <main>
    <header>
      <h1>Classical Melody Keyboard</h1>
      <p class="lead">Every key on your keyboard lights up with a gentle classical riff—press one key or tap a card, then listen all the way through (or line up a few; they patiently wait their turn!).</p>
      <div class="now-playing" role="status" aria-live="polite">
        <span class="label">Now playing</span>
        <span class="value">Press any key or tap a card to begin!</span>
      </div>
    </header>

    <div class="melody-toast" role="status" aria-live="assertive" aria-atomic="true">
      <div class="melody-toast__bubble">
        <span class="melody-toast__key" aria-hidden="true"></span>
        <div class="melody-toast__text">
          <span class="melody-toast__title"></span>
          <span class="melody-toast__composer"></span>
        </div>
      </div>
    </div>

    <section class="keys-grid" aria-label="Keyboard melody options"></section>

    <aside class="queue-panel" aria-label="Playback queue" aria-live="polite">
      <div class="queue-panel__header">
        <h2>Playback queue</h2>
        <button class="clear-queue" type="button" id="clearQueueButton" disabled>Clear queue</button>
      </div>
      <p class="queue-empty" id="queueEmptyMessage">No melodies queued yet—tap a card or press a key to line one up.</p>
      <p class="queue-summary" id="queueSummary" hidden>
        <span class="queue-summary__pill" id="queueCount"></span>
        <span class="queue-summary__text" id="queueDuration"></span>
      </p>
      <ol class="queue-list" role="list" aria-describedby="queueEmptyMessage"></ol>
    </aside>

    <div class="controls">
      <div class="volume-control">
        <label for="volumeSlider">Volume</label>
        <input type="range" id="volumeSlider" min="0" max="100" value="68" step="1" aria-label="Volume level" />
        <span class="volume-control__value" id="volumeValue" aria-live="polite">68%</span>
      </div>
      <button class="stop" type="button" id="stopButton">Stop the music</button>
    </div>

    <footer>
      Tip: Turn the volume to a comfy level, then explore the melodies together—line up as many keys as you like and they'll take turns.
    </footer>
  </main>

  <script>
    const NOTE_FREQUENCIES = {
      'C3': 130.81,
      'D3': 146.83,
      'E3': 164.81,
      'F3': 174.61,
      'G3': 196.0,
      'A3': 220.0,
      'Bb3': 233.08,
      'B3': 246.94,
      'C4': 261.63,
      'Cs4': 277.18,
      'D4': 293.66,
      'Ds4': 311.13,
      'E4': 329.63,
      'F4': 349.23,
      'Fs4': 369.99,
      'G4': 392.0,
      'Gs4': 415.3,
      'A4': 440.0,
      'As4': 466.16,
      'B4': 493.88,
      'C5': 523.25,
      'Cs5': 554.37,
      'D5': 587.33,
      'Ds5': 622.25,
      'E5': 659.26,
      'F5': 698.46,
      'Fs5': 739.99,
      'G5': 783.99,
      'Gs5': 830.61,
      'A5': 880.0,
      'B5': 987.77,
      'C6': 1046.5
    };

    const PATTERN_LIBRARY = {
      ode: {
        title: 'Ode to Joy',
        composer: 'L. v. Beethoven',
        notes: [
          { note: 'E4', duration: 420 },
          { note: 'E4', duration: 420 },
          { note: 'F4', duration: 420 },
          { note: 'G4', duration: 620 },
          { note: 'G4', duration: 420 },
          { note: 'F4', duration: 420 },
          { note: 'E4', duration: 420 },
          { note: 'D4', duration: 620 },
          { note: 'C4', duration: 420 },
          { note: 'C4', duration: 420 },
          { note: 'D4', duration: 420 },
          { note: 'E4', duration: 620 },
          { note: 'E4', duration: 420 },
          { note: 'D4', duration: 420 },
          { note: 'D4', duration: 840 }
        ]
      },
      mozart: {
        title: 'Eine Kleine Nachtmusik',
        composer: 'W. A. Mozart',
        notes: [
          { note: 'G4', duration: 420 },
          { note: 'G4', duration: 420 },
          { note: 'D4', duration: 420 },
          { note: 'E4', duration: 420 },
          { note: 'F4', duration: 420 },
          { note: 'F4', duration: 420 },
          { note: 'E4', duration: 420 },
          { note: 'D4', duration: 420 },
          { note: 'C4', duration: 420 },
          { note: 'E4', duration: 420 },
          { note: 'G4', duration: 840 },
          { note: 'G4', duration: 420 },
          { note: 'F4', duration: 420 },
          { note: 'E4', duration: 420 },
          { note: 'D4', duration: 840 }
        ]
      },
      minuet: {
        title: 'Minuet in G',
        composer: 'J. S. Bach',
        notes: [
          { note: 'G4', duration: 420 },
          { note: 'A4', duration: 420 },
          { note: 'B4', duration: 420 },
          { note: 'C5', duration: 420 },
          { note: 'D5', duration: 840 },
          { note: 'B4', duration: 420 },
          { note: 'C5', duration: 420 },
          { note: 'D5', duration: 420 },
          { note: 'E5', duration: 420 },
          { note: 'C5', duration: 840 },
          { note: 'A4', duration: 420 },
          { note: 'B4', duration: 420 },
          { note: 'C5', duration: 420 },
          { note: 'D5', duration: 420 },
          { note: 'B4', duration: 840 }
        ]
      },
      canon: {
        title: 'Canon in D',
        composer: 'J. Pachelbel',
        notes: [
          { note: 'Fs4', duration: 420 },
          { note: 'E4', duration: 420 },
          { note: 'Ds4', duration: 420 },
          { note: 'Cs4', duration: 420 },
          { note: 'B3', duration: 420 },
          { note: 'Cs4', duration: 420 },
          { note: 'Ds4', duration: 420 },
          { note: 'E4', duration: 420 },
          { note: 'Fs4', duration: 420 },
          { note: 'E4', duration: 420 },
          { note: 'Ds4', duration: 420 },
          { note: 'Cs4', duration: 420 },
          { note: 'B3', duration: 420 },
          { note: 'Cs4', duration: 420 },
          { note: 'Ds4', duration: 840 }
        ]
      },
      sugarPlum: {
        title: 'Dance of the Sugar Plum Fairy',
        composer: 'P. I. Tchaikovsky',
        notes: [
          { note: 'G4', duration: 420 },
          { note: 'REST', duration: 210 },
          { note: 'G4', duration: 420 },
          { note: 'REST', duration: 210 },
          { note: 'G4', duration: 420 },
          { note: 'Ds5', duration: 420 },
          { note: 'Gs4', duration: 420 },
          { note: 'G4', duration: 420 },
          { note: 'Ds5', duration: 420 },
          { note: 'Gs4', duration: 420 },
          { note: 'G4', duration: 420 },
          { note: 'Ds5', duration: 420 },
          { note: 'Gs4', duration: 420 },
          { note: 'G4', duration: 420 },
          { note: 'Ds5', duration: 840 }
        ]
      },
      morning: {
        title: 'Morning Mood',
        composer: 'E. Grieg',
        notes: [
          { note: 'E4', duration: 420 },
          { note: 'G4', duration: 420 },
          { note: 'A4', duration: 420 },
          { note: 'B4', duration: 420 },
          { note: 'C5', duration: 840 },
          { note: 'B4', duration: 420 },
          { note: 'A4', duration: 420 },
          { note: 'G4', duration: 420 },
          { note: 'E4', duration: 420 },
          { note: 'G4', duration: 420 },
          { note: 'A4', duration: 420 },
          { note: 'B4', duration: 420 },
          { note: 'C5', duration: 840 },
          { note: 'B4', duration: 420 },
          { note: 'A4', duration: 840 }
        ]
      },
      twinkle: {
        title: 'Twinkle, Twinkle Little Star',
        composer: 'W. A. Mozart',
        notes: [
          { note: 'C4', duration: 420 },
          { note: 'C4', duration: 420 },
          { note: 'G4', duration: 420 },
          { note: 'G4', duration: 420 },
          { note: 'A4', duration: 420 },
          { note: 'A4', duration: 420 },
          { note: 'G4', duration: 840 },
          { note: 'F4', duration: 420 },
          { note: 'F4', duration: 420 },
          { note: 'E4', duration: 420 },
          { note: 'E4', duration: 420 },
          { note: 'D4', duration: 420 },
          { note: 'D4', duration: 420 },
          { note: 'C4', duration: 840 }
        ]
      },
      clair: {
        title: 'Clair de Lune',
        composer: 'C. Debussy',
        notes: [
          { note: 'D4', duration: 420 },
          { note: 'Fs4', duration: 420 },
          { note: 'A4', duration: 620 },
          { note: 'D5', duration: 420 },
          { note: 'Cs5', duration: 420 },
          { note: 'A4', duration: 620 },
          { note: 'Fs4', duration: 420 },
          { note: 'D4', duration: 840 }
        ]
      },
      swan: {
        title: 'Swan Lake',
        composer: 'P. I. Tchaikovsky',
        notes: [
          { note: 'A4', duration: 420 },
          { note: 'E5', duration: 420 },
          { note: 'F5', duration: 420 },
          { note: 'E5', duration: 420 },
          { note: 'D5', duration: 420 },
          { note: 'B4', duration: 420 },
          { note: 'A4', duration: 420 },
          { note: 'Fs4', duration: 420 },
          { note: 'E4', duration: 840 }
        ]
      },
      blueDanube: {
        title: 'The Blue Danube',
        composer: 'J. Strauss II',
        notes: [
          { note: 'D4', duration: 420 },
          { note: 'Fs4', duration: 420 },
          { note: 'A4', duration: 420 },
          { note: 'D5', duration: 620 },
          { note: 'A4', duration: 420 },
          { note: 'Fs4', duration: 420 },
          { note: 'D4', duration: 620 },
          { note: 'Fs4', duration: 420 },
          { note: 'A4', duration: 420 },
          { note: 'D5', duration: 840 }
        ]
      },
      spring: {
        title: 'Spring',
        composer: 'A. Vivaldi',
        notes: [
          { note: 'E5', duration: 420 },
          { note: 'E5', duration: 420 },
          { note: 'E5', duration: 420 },
          { note: 'C5', duration: 420 },
          { note: 'E5', duration: 420 },
          { note: 'Fs5', duration: 420 },
          { note: 'G5', duration: 840 },
          { note: 'E5', duration: 420 },
          { note: 'C5', duration: 420 },
          { note: 'E5', duration: 420 },
          { note: 'G5', duration: 840 }
        ]
      },
      gymno: {
        title: 'Gymnopédie No. 1',
        composer: 'E. Satie',
        notes: [
          { note: 'D4', duration: 420 },
          { note: 'A4', duration: 620 },
          { note: 'Fs4', duration: 420 },
          { note: 'D4', duration: 420 },
          { note: 'G4', duration: 420 },
          { note: 'B4', duration: 620 },
          { note: 'A4', duration: 420 },
          { note: 'Fs4', duration: 840 }
        ]
      },
      lullaby: {
        title: "Brahms' Lullaby",
        composer: 'J. Brahms',
        notes: [
          { note: 'G4', duration: 420 },
          { note: 'E4', duration: 420 },
          { note: 'G4', duration: 420 },
          { note: 'E4', duration: 420 },
          { note: 'G4', duration: 420 },
          { note: 'B4', duration: 420 },
          { note: 'A4', duration: 840 },
          { note: 'A4', duration: 420 },
          { note: 'Fs4', duration: 420 },
          { note: 'A4', duration: 420 },
          { note: 'Fs4', duration: 420 },
          { note: 'A4', duration: 420 },
          { note: 'D5', duration: 420 },
          { note: 'B4', duration: 840 }
        ]
      }
    };

    const KEY_ROWS = [
      ['Escape', '`', '1', '2', '3', '4', '5', '6', '7', '8', '9', '0', '-', '=', 'Backspace'],
      ['Tab', 'q', 'w', 'e', 'r', 't', 'y', 'u', 'i', 'o', 'p', '[', ']', '\'],
      ['CapsLock', 'a', 's', 'd', 'f', 'g', 'h', 'j', 'k', 'l', ';', "'", 'Enter'],
      ['Shift', 'z', 'x', 'c', 'v', 'b', 'n', 'm', ',', '.', '/'],
      ['Control', 'Alt', 'Space', 'AltGraph', 'Meta'],
      ['Insert', 'Home', 'PageUp', 'Delete', 'End', 'PageDown', 'ArrowLeft', 'ArrowDown', 'ArrowUp', 'ArrowRight']
    ];

    const COLOR_POOL = [
      'var(--accent-1)',
      'var(--accent-2)',
      'var(--accent-3)',
      'var(--accent-4)',
      'var(--accent-5)',
      'var(--accent-6)'
    ];

    const PATTERN_SEQUENCE = [
      'ode',
      'mozart',
      'minuet',
      'canon',
      'sugarPlum',
      'morning',
      'twinkle',
      'clair',
      'swan',
      'blueDanube',
      'spring',
      'gymno',
      'lullaby'
    ];

    const FRIENDLY_NAMES = {
      'Escape': 'Esc',
      '`': 'Backtick',
      '-': 'Minus',
      '=': 'Equals',
      'Backspace': 'Backspace',
      'Tab': 'Tab',
      '[': 'Left Bracket',
      ']': 'Right Bracket',
      '\': 'Backslash',
      'CapsLock': 'Caps Lock',
      ';': 'Semicolon',
      "'": 'Apostrophe',
      'Enter': 'Enter',
      'Shift': 'Shift',
      ',': 'Comma',
      '.': 'Period',
      '/': 'Slash',
      'Control': 'Ctrl',
      'Alt': 'Alt',
      'Space': 'Space',
      'AltGraph': 'AltGr',
      'Meta': 'Meta',
      'Insert': 'Insert',
      'Home': 'Home',
      'PageUp': 'Pg Up',
      'Delete': 'Delete',
      'End': 'End',
      'PageDown': 'Pg Dn',
      'ArrowLeft': '←',
      'ArrowDown': '↓',
      'ArrowUp': '↑',
      'ArrowRight': '→'
    };

    function datasetKeyFor(key) {
      switch (key) {
        case 'Escape': return 'escape';
        case ' ': return 'space';
        case '`': return 'backtick';
        case '-': return 'minus';
        case '=': return 'equals';
        case 'Backspace': return 'backspace';
        case 'Tab': return 'tab';
        case '[': return 'leftbracket';
        case ']': return 'rightbracket';
        case '\': return 'backslash';
        case 'CapsLock': return 'capslock';
        case ';': return 'semicolon';
        case "'": return 'apostrophe';
        case 'Enter': return 'enter';
        case 'Shift': return 'shift';
        case ',': return 'comma';
        case '.': return 'period';
        case '/': return 'slash';
        case 'Control': return 'control';
        case 'Alt': return 'alt';
        case 'Space': return 'space';
        case 'AltGraph': return 'altgraph';
        case 'Meta': return 'meta';
        case 'Insert': return 'insert';
        case 'Home': return 'home';
        case 'PageUp': return 'pageup';
        case 'Delete': return 'delete';
        case 'End': return 'end';
        case 'PageDown': return 'pagedown';
        case 'ArrowLeft': return 'arrowleft';
        case 'ArrowDown': return 'arrowdown';
        case 'ArrowUp': return 'arrowup';
        case 'ArrowRight': return 'arrowright';
        default: return key;
      }
    }

    function displayLabelFor(key) {
      if (key === ' ') {
        return 'Space';
      }
      if (FRIENDLY_NAMES[key]) {
        return FRIENDLY_NAMES[key];
      }
      return key.length === 1 ? key.toUpperCase() : key;
    }

    const melodies = {};
    const keyMatcher = {};
    const keysGrid = document.querySelector('.keys-grid');
    const nowPlayingValue = document.querySelector('.now-playing .value');
    const queueList = document.querySelector('.queue-list');
    const queueEmptyMessage = document.getElementById('queueEmptyMessage');
    const queueSummary = document.getElementById('queueSummary');
    const queueCount = document.getElementById('queueCount');
    const queueDuration = document.getElementById('queueDuration');
    const clearQueueButton = document.getElementById('clearQueueButton');
    const melodyToast = document.querySelector('.melody-toast');
    const melodyToastKey = melodyToast ? melodyToast.querySelector('.melody-toast__key') : null;
    const melodyToastTitle = melodyToast ? melodyToast.querySelector('.melody-toast__title') : null;
    const melodyToastComposer = melodyToast ? melodyToast.querySelector('.melody-toast__composer') : null;
    const volumeSlider = document.getElementById('volumeSlider');
    const volumeValue = document.getElementById('volumeValue');
    const stopButton = document.getElementById('stopButton');
    const STORAGE_KEYS = {
      volume: 'classicalKeyboard.volumeLevel'
    };

    const KEY_ROW_LABELS = [
      'Esc & numbers',
      'Top letters',
      'Home row',
      'Bottom row',
      'Space & modifiers',
      'Navigation keys'
    ];

    const rowContainers = [];
    if (keysGrid) {
      KEY_ROWS.forEach((_, rowIndex) => {
        const wrapper = document.createElement('div');
        wrapper.className = 'keys-row-wrapper';

        const labelId = `keys-row-label-${rowIndex + 1}`;
        const label = document.createElement('div');
        label.className = 'keys-row-label';
        label.id = labelId;
        label.textContent = KEY_ROW_LABELS[rowIndex] || `Row ${rowIndex + 1}`;
        wrapper.appendChild(label);

        const rowElement = document.createElement('div');
        rowElement.className = 'keys-row';
        rowElement.setAttribute('role', 'group');
        rowElement.setAttribute('aria-labelledby', labelId);
        wrapper.appendChild(rowElement);

        keysGrid.appendChild(wrapper);
        rowContainers.push(rowElement);
      });
    }

    const keyEntries = [];
    KEY_ROWS.forEach((row, rowIndex) => {
      row.forEach((key) => {
        const datasetKey = datasetKeyFor(key);
        const display = displayLabelFor(key);
        keyEntries.push({ key, datasetKey, display, rowIndex });
      });
    });

    keyEntries.forEach((entry, index) => {
      const patternId = PATTERN_SEQUENCE[index % PATTERN_SEQUENCE.length];
      const pattern = PATTERN_LIBRARY[patternId];
      const color = COLOR_POOL[index % COLOR_POOL.length];

      melodies[entry.datasetKey] = {
        title: pattern.title,
        composer: pattern.composer,
        keyLabel: entry.display,
        notes: pattern.notes
      };

      const card = document.createElement('article');
      card.className = 'key-card';
      card.dataset.key = entry.datasetKey;
      card.dataset.color = color;
      card.style.setProperty('--card-color', color);
      card.innerHTML = `
        <span class="letter" aria-hidden="true">${entry.display}</span>
        <span class="title">${pattern.title}</span>
        <span class="subtitle">${pattern.composer}</span>
        <div class="progress-track" aria-hidden="true">
          <div class="progress-bar"></div>
        </div>
      `;
      card.setAttribute('title', `${entry.display} key · ${pattern.title}`);
      card.setAttribute('aria-label', `${entry.display} key plays ${pattern.title}`);
      card.setAttribute('role', 'button');
      card.setAttribute('tabindex', '0');
      const host = rowContainers[entry.rowIndex] || keysGrid;
      if (host) {
        host.appendChild(card);
      }

      const letterSpan = card.querySelector('.letter');
      if (entry.display.length > 2) {
        letterSpan.style.fontSize = 'clamp(1.1rem, 2.4vw, 1.5rem)';
        letterSpan.style.padding = '0 0.45rem';
        letterSpan.style.letterSpacing = '0.02em';
      }
      if (entry.display.length > 7) {
        letterSpan.style.fontSize = 'clamp(0.95rem, 2vw, 1.2rem)';
      }

      const gradient = `linear-gradient(145deg, ${color}33, #ffffff)`;
      letterSpan.style.background = color;
      card.style.background = gradient;

      const activate = () => enqueueMelody(entry.datasetKey);

      card.addEventListener('click', activate);
      card.addEventListener('keydown', (event) => {
        if (event.key === 'Enter' || event.key === ' ') {
          event.preventDefault();
          event.stopPropagation();
          activate();
        }
      });

      keyMatcher[entry.key] = entry.datasetKey;
      keyMatcher[entry.key.toLowerCase()] = entry.datasetKey;
      if (entry.key.length === 1) {
        keyMatcher[entry.key.toUpperCase()] = entry.datasetKey;
      }
      if (entry.key === ' ' || entry.key === 'Space') {
        keyMatcher[' '] = entry.datasetKey;
        keyMatcher['Spacebar'] = entry.datasetKey;
      }
      if (entry.key === 'Escape') {
        keyMatcher['Esc'] = entry.datasetKey;
      }
      if (entry.key === 'Enter') {
        keyMatcher['Return'] = entry.datasetKey;
      }
      if (entry.key === 'Meta') {
        keyMatcher['OS'] = entry.datasetKey;
        keyMatcher['Win'] = entry.datasetKey;
      }
      if (entry.key === 'AltGraph') {
        keyMatcher['AltGr'] = entry.datasetKey;
      }
    });

    const audioContext = new (window.AudioContext || window.webkitAudioContext)();
    const masterGain = audioContext.createGain();
    masterGain.connect(audioContext.destination);

    const playbackQueue = [];
    let isProcessingQueue = false;
    let cancelCurrent = false;
    let activeNodes = [];
    let currentCard = null;
    let currentDurationEstimate = 0;
    let toastHideTimeout = null;

    function hideMelodyToast(clearTimer = false) {
      if (!melodyToast) {
        return;
      }
      if (clearTimer && toastHideTimeout) {
        clearTimeout(toastHideTimeout);
        toastHideTimeout = null;
      }
      delete melodyToast.dataset.visible;
    }

    function showMelodyToast(key) {
      if (!melodyToast) {
        return;
      }
      const melody = melodies[key];
      if (!melody) {
        return;
      }
      if (toastHideTimeout) {
        clearTimeout(toastHideTimeout);
        toastHideTimeout = null;
      }

      if (melodyToastKey) {
        const label = melody.keyLabel || key;
        const normalized = label.length === 1 ? label.toUpperCase() : label;
        const trimmed = normalized.length > 10 ? `${normalized.slice(0, 9)}…` : normalized;
        melodyToastKey.textContent = trimmed;
      }

      if (melodyToastTitle) {
        melodyToastTitle.textContent = melody.title || '';
      }

      if (melodyToastComposer) {
        if (melody.composer) {
          melodyToastComposer.textContent = `by ${melody.composer}`;
          melodyToastComposer.style.display = '';
        } else {
          melodyToastComposer.textContent = '';
          melodyToastComposer.style.display = 'none';
        }
      }

      const card = document.querySelector(`.key-card[data-key="${key}"]`);
      if (card && card.dataset && card.dataset.color) {
        const accent = card.dataset.color;
        melodyToast.style.setProperty('--toast-accent', accent);
      } else {
        melodyToast.style.setProperty('--toast-accent', 'var(--accent-4)');
      }

      melodyToast.dataset.visible = 'true';
      toastHideTimeout = setTimeout(() => {
        toastHideTimeout = null;
        hideMelodyToast();
      }, 2600);
    }

    function syncQueueButtonState() {
      if (!clearQueueButton) {
        return;
      }
      clearQueueButton.disabled = playbackQueue.length === 0;
    }

    function renderQueue() {
      if (!queueList) {
        syncQueueButtonState();
        return;
      }

      queueList.innerHTML = '';

      const activeKey = currentCard && currentCard.dataset ? currentCard.dataset.key : null;
      const activeMelody = activeKey ? melodies[activeKey] : null;

      if (activeMelody) {
        const item = document.createElement('li');
        item.className = 'queue-item is-playing';
        item.innerHTML = `
          <span class="queue-pill">${activeMelody.title}</span>
          <span class="queue-meta">Now playing</span>
        `;
        queueList.appendChild(item);
      }

      const previewCount = 6;
      const upcoming = playbackQueue.slice(0, previewCount);
      upcoming.forEach((key, index) => {
        const melody = melodies[key];
        if (!melody) {
          return;
        }
        const item = document.createElement('li');
        item.className = 'queue-item';
        if (index === 0) {
          item.classList.add('is-next');
        }
        const label = index === 0 ? 'Next up' : `In line #${index + 1}`;
        item.innerHTML = `
          <span class="queue-pill">${melody.title}</span>
          <span class="queue-meta">${label}</span>
        `;
        queueList.appendChild(item);
      });

      if (playbackQueue.length > upcoming.length) {
        const remaining = playbackQueue.length - upcoming.length;
        const item = document.createElement('li');
        item.className = 'queue-item queue-item--more';
        item.innerHTML = `<span class="queue-meta">+ ${remaining} more queued</span>`;
        queueList.appendChild(item);
      }

      const hasEntries = queueList.children.length > 0;
      if (queueEmptyMessage) {
        queueEmptyMessage.hidden = hasEntries;
      }
      queueList.hidden = !hasEntries;

      const queuedMelodies = playbackQueue.filter((key) => melodies[key]);
      const totalItems = (activeMelody ? 1 : 0) + queuedMelodies.length;
      const upcomingDuration = queuedMelodies.reduce((total, key) => {
        const melody = melodies[key];
        return melody ? total + totalDurationForMelody(melody) : total;
      }, 0);
      const activeDuration = activeMelody ? currentDurationEstimate : 0;
      const totalDuration = activeDuration + upcomingDuration;

      if (queueSummary) {
        if (totalItems > 0) {
          queueSummary.hidden = false;
          if (queueCount) {
            queueCount.textContent = totalItems === 1 ? '1 melody' : `${totalItems} melodies`;
          }
          if (queueDuration) {
            queueDuration.textContent = totalDuration > 0
              ? `Approx. ${formatDuration(totalDuration)}`
              : 'Approx. 0s';
          }
        } else {
          queueSummary.hidden = true;
        }
      }

      syncQueueButtonState();
    }

    function totalDurationForMelody(melody) {
      if (!melody || !Array.isArray(melody.notes)) {
        return 0;
      }
      const base = melody.notes.reduce((total, segment) => {
        const duration = typeof segment.duration === 'number' ? segment.duration : 0;
        return total + Math.max(duration, 0);
      }, 0);
      const padding = melody.notes.length * 60;
      return base + padding;
    }

    function formatDuration(durationMs) {
      if (!durationMs || !Number.isFinite(durationMs)) {
        return '0s';
      }
      const totalSeconds = Math.max(Math.round(durationMs / 1000), 0);
      const minutes = Math.floor(totalSeconds / 60);
      const seconds = totalSeconds % 60;
      if (minutes <= 0) {
        return `${seconds}s`;
      }
      return `${minutes}m ${seconds.toString().padStart(2, '0')}s`;
    }

    function clamp(value, min, max) {
      return Math.min(Math.max(value, min), max);
    }

    function sliderValueToGain(value) {
      const normalized = clamp(Number(value) / 100, 0, 1);
      const curved = Math.pow(normalized, 1.5);
      return +(curved * 0.9).toFixed(4);
    }

    function paintVolumeSlider(value) {
      if (!volumeSlider) {
        return;
      }
      const percent = clamp(Number(value), 0, 100);
      const fill = `${percent}%`;
      volumeSlider.style.background = `linear-gradient(90deg, var(--accent-4) ${fill}, rgba(106, 76, 147, 0.24) ${fill})`;
    }

    function updateVolumeDisplay(value) {
      const rounded = Math.round(clamp(Number(value), 0, 100));
      if (volumeValue) {
        volumeValue.textContent = `${rounded}%`;
      }
      if (volumeSlider) {
        volumeSlider.setAttribute('aria-valuenow', String(rounded));
        volumeSlider.setAttribute('aria-valuetext', `${rounded} percent volume`);
      }
    }

    function applyVolume(value, { persist = false } = {}) {
      const numericValue = clamp(Number(value), 0, 100);
      const gainValue = sliderValueToGain(numericValue);
      masterGain.gain.setTargetAtTime(gainValue, audioContext.currentTime, 0.01);
      updateVolumeDisplay(numericValue);
      paintVolumeSlider(numericValue);
      if (persist && window.localStorage) {
        try {
          window.localStorage.setItem(STORAGE_KEYS.volume, String(numericValue));
        } catch (err) {
          /* ignore storage errors */
        }
      }
    }

    function readStoredVolume() {
      if (!window.localStorage) {
        return null;
      }
      try {
        const stored = window.localStorage.getItem(STORAGE_KEYS.volume);
        if (stored === null) {
          return null;
        }
        const parsed = Number.parseFloat(stored);
        return Number.isNaN(parsed) ? null : clamp(parsed, 0, 100);
      } catch (err) {
        return null;
      }
    }

    function startProgress(card, durationMs) {
      if (!card) {
        return;
      }
      const bar = card.querySelector('.progress-bar');
      if (!bar) {
        return;
      }
      const safeDuration = Math.max(durationMs || 0, 400);
      bar.style.transition = 'none';
      bar.style.width = '0%';
      requestAnimationFrame(() => {
        bar.style.transition = `width ${safeDuration}ms linear`;
        bar.style.width = '100%';
      });
    }

    function clearProgress(card) {
      if (!card) {
        return;
      }
      const bar = card.querySelector('.progress-bar');
      if (!bar) {
        return;
      }
      requestAnimationFrame(() => {
        bar.style.transition = 'width 220ms ease';
        bar.style.width = '0%';
      });
    }

    function describeMelody(key) {
      const melody = melodies[key];
      if (!melody) {
        return null;
      }
      return `${melody.title} — ${melody.composer} (${melody.keyLabel} key)`;
    }

    function refreshNowPlayingStatus() {
      if (!nowPlayingValue) {
        return;
      }
      if (currentCard && currentCard.dataset && currentCard.dataset.key) {
        const description = describeMelody(currentCard.dataset.key);
        if (description) {
          nowPlayingValue.textContent = description;
          return;
        }
      }
      if (playbackQueue.length > 0) {
        const nextDescription = describeMelody(playbackQueue[0]);
        if (nextDescription) {
          nowPlayingValue.textContent = `Queued: ${nextDescription}`;
          return;
        }
      }
      nowPlayingValue.textContent = 'Press any key or tap a card to begin!';
    }

    function wait(ms) {
      return new Promise(resolve => setTimeout(resolve, ms));
    }

    function updateQueueIndicators() {
      const cards = document.querySelectorAll('.key-card');
      const queuedSet = new Set(playbackQueue);
      const currentKey = currentCard ? currentCard.dataset.key : null;
      cards.forEach((card) => {
        if (queuedSet.has(card.dataset.key) && card.dataset.key !== currentKey) {
          card.dataset.queued = 'true';
        } else {
          delete card.dataset.queued;
        }
      });
      refreshNowPlayingStatus();
      renderQueue();
    }

    function setActiveCard(key, totalDuration) {
      unsetActiveCard();
      const card = document.querySelector(`.key-card[data-key="${key}"]`);
      if (card) {
        currentCard = card;
        currentDurationEstimate = typeof totalDuration === 'number' ? totalDuration : 0;
        card.dataset.active = 'true';
        delete card.dataset.queued;
        if (typeof totalDuration === 'number' && totalDuration > 0) {
          startProgress(card, totalDuration);
        }
        refreshNowPlayingStatus();
        renderQueue();
      }
    }

    function unsetActiveCard() {
      if (currentCard) {
        const previous = currentCard;
        previous.dataset.active = 'false';
        clearProgress(previous);
        currentCard = null;
        currentDurationEstimate = 0;
        updateQueueIndicators();
      }
    }

    async function playSegment(segment) {
      if (cancelCurrent) {
        return;
      }

      const durationMs = typeof segment.duration === 'number' ? segment.duration : 0;
      const frequency = NOTE_FREQUENCIES[segment.note];
      if (!frequency) {
        await wait(durationMs);
        return;
      }

      const now = audioContext.currentTime;
      const oscillator = audioContext.createOscillator();
      const overtone = audioContext.createOscillator();
      const vibrato = audioContext.createOscillator();
      const gainNode = audioContext.createGain();
      const overtoneGain = audioContext.createGain();
      const vibratoGain = audioContext.createGain();

      oscillator.type = 'triangle';
      oscillator.frequency.setValueAtTime(frequency, now);

      overtone.type = 'sine';
      overtone.frequency.setValueAtTime(frequency * 2, now);
      overtoneGain.gain.value = 0.18;

      vibrato.type = 'sine';
      vibrato.frequency.value = 5.5;
      vibratoGain.gain.value = Math.max(frequency * 0.008, 1.5);

      oscillator.connect(gainNode);
      overtone.connect(overtoneGain);
      overtoneGain.connect(gainNode);
      vibrato.connect(vibratoGain);
      vibratoGain.connect(oscillator.frequency);
      gainNode.connect(masterGain);

      const totalSeconds = Math.max(durationMs / 1000, 0.12);
      const attack = Math.min(0.09, totalSeconds * 0.3);
      const decay = Math.min(0.1, totalSeconds * 0.2);
      const sustainLevel = 0.42;
      const release = Math.min(0.2, totalSeconds * 0.35);
      const sustain = Math.max(totalSeconds - attack - decay - release, 0.02);

      gainNode.gain.cancelScheduledValues(now);
      gainNode.gain.setValueAtTime(0.0001, now);
      gainNode.gain.exponentialRampToValueAtTime(0.9, now + attack);
      gainNode.gain.setTargetAtTime(sustainLevel, now + attack, decay);
      gainNode.gain.setTargetAtTime(0.0001, now + attack + sustain, release);

      oscillator.start(now);
      overtone.start(now);
      vibrato.start(now);

      const nodeGroup = { gainNode, oscillators: [oscillator, overtone, vibrato] };
      activeNodes.push(nodeGroup);

      await wait(Math.max(durationMs - 40, 10));
      if (!cancelCurrent) {
        gainNode.gain.exponentialRampToValueAtTime(0.0001, audioContext.currentTime + 0.05);
        await wait(60);
      }

      nodeGroup.oscillators.forEach((node) => {
        try {
          node.stop();
        } catch (err) {
          /* oscillator may already be stopped */
        }
        try {
          node.disconnect();
        } catch (err) {
          /* ignore */
        }
      });
      [gainNode, overtoneGain, vibratoGain].forEach((node) => {
        try {
          node.disconnect();
        } catch (err) {
          /* ignore */
        }
      });

      activeNodes = activeNodes.filter((entry) => entry !== nodeGroup);
    }

    async function runMelody(key) {
      const melody = melodies[key];
      if (!melody) {
        return;
      }

      await audioContext.resume();
      const totalDuration = totalDurationForMelody(melody);
      setActiveCard(key, totalDuration);

      for (const segment of melody.notes) {
        if (cancelCurrent) {
          break;
        }
        await playSegment(segment);
      }

      if (!cancelCurrent) {
        await wait(140);
        unsetActiveCard();
      }
      refreshNowPlayingStatus();
    }

    async function processQueue() {
      if (isProcessingQueue) {
        return;
      }
      isProcessingQueue = true;
      try {
        while (playbackQueue.length > 0) {
          if (cancelCurrent) {
            playbackQueue.length = 0;
            break;
          }
          const nextKey = playbackQueue.shift();
          updateQueueIndicators();
          await runMelody(nextKey);
        }
      } finally {
        isProcessingQueue = false;
        if (!cancelCurrent) {
          unsetActiveCard();
        }
        cancelCurrent = false;
        updateQueueIndicators();
      }
    }

    function enqueueMelody(key) {
      if (!melodies[key]) {
        return;
      }
      showMelodyToast(key);
      playbackQueue.push(key);
      updateQueueIndicators();
      if (!isProcessingQueue) {
        cancelCurrent = false;
        processQueue();
      }
    }

    function stopPlayback() {
      if (!isProcessingQueue && activeNodes.length === 0) {
        return;
      }
      cancelCurrent = true;
      playbackQueue.length = 0;
      updateQueueIndicators();
      const now = audioContext.currentTime;
      activeNodes.forEach(({ gainNode, oscillators }) => {
        try {
          gainNode.gain.cancelScheduledValues(now);
          gainNode.gain.setTargetAtTime(0.0001, now, 0.05);
        } catch (err) {
          /* ignore */
        }
        oscillators.forEach((node) => {
          try {
            node.stop(now + 0.05);
          } catch (err) {
            /* ignore */
          }
        });
      });
      activeNodes = [];
      unsetActiveCard();
      hideMelodyToast(true);
    }

    document.addEventListener('keydown', (event) => {
      const rawKey = event.key;
      const lowerKey = typeof rawKey === 'string' ? rawKey.toLowerCase() : rawKey;
      const upperKey = typeof rawKey === 'string' ? rawKey.toUpperCase() : rawKey;
      const datasetKey = keyMatcher[rawKey] || keyMatcher[lowerKey] || keyMatcher[upperKey];
      if (datasetKey) {
        event.preventDefault();
        enqueueMelody(datasetKey);
      }
    });

    if (stopButton) {
      stopButton.addEventListener('click', () => {
        stopPlayback();
      });
    }

    if (clearQueueButton) {
      clearQueueButton.addEventListener('click', () => {
        if (playbackQueue.length === 0) {
          return;
        }
        playbackQueue.length = 0;
        updateQueueIndicators();
      });
    }

    refreshNowPlayingStatus();
    renderQueue();

    const initialVolume = (() => {
      const stored = readStoredVolume();
      if (stored !== null) {
        return stored;
      }
      if (volumeSlider && typeof volumeSlider.value === 'string') {
        const parsed = Number.parseFloat(volumeSlider.value);
        if (!Number.isNaN(parsed)) {
          return clamp(parsed, 0, 100);
        }
      }
      return 68;
    })();

    applyVolume(initialVolume);
    if (volumeSlider) {
      volumeSlider.value = String(initialVolume);
      paintVolumeSlider(initialVolume);
      volumeSlider.addEventListener('input', () => {
        applyVolume(volumeSlider.value);
      });
      ['change', 'blur'].forEach((eventName) => {
        volumeSlider.addEventListener(eventName, () => {
          applyVolume(volumeSlider.value, { persist: true });
        });
      });
    }

    setTimeout(() => {
      const cards = document.querySelectorAll('.key-card');
      cards.forEach((card, index) => {
        setTimeout(() => {
          card.dataset.active = 'true';
          setTimeout(() => {
            if (card !== currentCard) {
              card.dataset.active = 'false';
            }
          }, 320);
        }, index * 60);
      });
    }, 300);
  </script>
</body>
</html>

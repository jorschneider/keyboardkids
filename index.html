<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1" />
  <title>Keyboard Kids</title>
  <style>
    @import url('https://fonts.googleapis.com/css2?family=Baloo+2:wght@400;600;700&family=Nunito:wght@400;600;700&display=swap');
    :root {
      color-scheme: light;
      --bg: #fff6f0;
      --bg-secondary: #fef3ff;
      --panel: #ffffff;
      --text: #30263b;
      --muted-text: rgba(48, 38, 59, 0.7);
      --accent-1: #ff8ba0;
      --accent-2: #ffa94d;
      --accent-3: #7bdff2;
      --accent-4: #9d6bff;
      --accent-5: #ffd166;
      --accent-6: #6ede8a;
      --accent-7: #ffa3d7;
      --toast-accent: var(--accent-4);
    }

    * {
      box-sizing: border-box;
    }

    body {
      margin: 0;
      font-family: 'Baloo 2', 'Nunito', 'Helvetica Neue', Arial, sans-serif;
      background: radial-gradient(circle at top left, var(--bg) 0%, var(--bg-secondary) 45%, #ffeef5 100%);
      color: var(--text);
      min-height: 100vh;
      display: flex;
      align-items: center;
      justify-content: center;
      padding: 2rem 1.5rem 3rem;
      position: relative;
      overflow-x: hidden;
    }

    body::before,
    body::after {
      content: "";
      position: fixed;
      border-radius: 50%;
      filter: blur(0.5px);
      opacity: 0.45;
      z-index: 0;
    }

    body::before {
      width: 420px;
      height: 420px;
      background: radial-gradient(circle, rgba(255, 195, 160, 0.55), rgba(255, 138, 160, 0));
      top: -140px;
      right: -120px;
    }

    body::after {
      width: 520px;
      height: 520px;
      background: radial-gradient(circle, rgba(155, 107, 255, 0.4), rgba(123, 223, 242, 0));
      bottom: -180px;
      left: -160px;
    }

    main {
      max-width: 1040px;
      width: 100%;
      background: var(--panel);
      border-radius: 32px;
      box-shadow: 0 24px 70px rgba(157, 107, 255, 0.2);
      padding: 2.75rem 2.25rem 3rem;
      position: relative;
      overflow: hidden;
      isolation: isolate;
    }

    main::after {
      content: "";
      position: absolute;
      inset: auto -140px -140px auto;
      width: 360px;
      height: 360px;
      background: radial-gradient(circle at center, rgba(123, 223, 242, 0.55), rgba(255, 161, 77, 0.25));
      border-radius: 50%;
      z-index: 0;
      filter: blur(0.5px);
    }

    main::before {
      content: "";
      position: absolute;
      inset: -160px auto auto -120px;
      width: 320px;
      height: 320px;
      background: radial-gradient(circle at top right, rgba(255, 138, 160, 0.55), rgba(255, 209, 102, 0.2));
      border-radius: 50%;
      z-index: 0;
      filter: blur(0.5px);
    }

    header {
      position: relative;
      z-index: 1;
      text-align: center;
      margin-bottom: 2.75rem;
    }

    header::after {
      content: "";
      position: absolute;
      inset: auto 50% -36px 50%;
      transform: translateX(-50%);
      width: min(320px, 70%);
      height: 12px;
      background: linear-gradient(90deg, rgba(255, 138, 160, 0.35), rgba(123, 223, 242, 0.6), rgba(255, 209, 102, 0.35));
      border-radius: 999px;
      opacity: 0.9;
    }

    h1 {
      margin: 0 0 0.75rem;
      font-size: clamp(2.4rem, 5.5vw, 3.4rem);
      line-height: 1.05;
      background: linear-gradient(120deg, var(--accent-4), var(--accent-1), var(--accent-2));
      -webkit-background-clip: text;
      background-clip: text;
      color: transparent;
      text-shadow: 0 8px 24px rgba(157, 107, 255, 0.3);
    }

    p.lead {
      margin: 0 auto;
      max-width: 640px;
      font-size: 1.1rem;
      line-height: 1.65;
      color: var(--muted-text);
    }

    .now-playing {
      margin: 1.9rem auto 0;
      max-width: 720px;
      background: rgba(255, 255, 255, 0.85);
      border-radius: 22px;
      padding: 0.95rem 1.4rem;
      display: flex;
      flex-wrap: wrap;
      justify-content: center;
      align-items: center;
      gap: 0.6rem;
      font-size: 1rem;
      box-shadow: 0 12px 28px rgba(157, 107, 255, 0.18);
    }

    .now-playing .label {
      font-weight: 700;
      text-transform: uppercase;
      letter-spacing: 0.1em;
      font-size: 0.82rem;
      color: rgba(48, 38, 59, 0.55);
    }

    .now-playing .value {
      font-weight: 600;
      color: var(--text);
    }

    .keys-grid {
      position: relative;
      z-index: 1;
      display: flex;
      flex-direction: column;
      gap: 1.7rem;
    }

    .keys-grid {
      position: relative;
      z-index: 1;
      margin-top: 3rem;
      display: grid;
      grid-template-columns: repeat(auto-fit, minmax(220px, 1fr));
      gap: 1.5rem;
    }

    .melody-card {
      background: linear-gradient(180deg, rgba(255, 255, 255, 0.98), rgba(255, 255, 255, 0.78));
      border-radius: 28px;
      padding: 1.6rem 1.45rem 2.2rem;
      display: flex;
      flex-direction: column;
      text-align: left;
      cursor: pointer;
      box-shadow: 0 18px 38px rgba(48, 38, 59, 0.14);
      transition: transform 0.25s ease, box-shadow 0.25s ease;
      border: 3px solid transparent;
      position: relative;
      overflow: hidden;
      --card-color: var(--accent-4);
    }

    .melody-card::before {
      content: "";
      position: absolute;
      inset: -20% auto auto -20%;
      width: 200px;
      height: 200px;
      background: radial-gradient(circle at top left, rgba(255, 255, 255, 0.65), transparent 72%);
      opacity: 0;
      transition: opacity 0.3s ease;
    }

    .melody-card:focus-visible {
      outline: 3px solid rgba(157, 107, 255, 0.6);
      outline-offset: 4px;
    }

    .melody-card .spot-icon {
      font-size: 2.15rem;
      filter: drop-shadow(0 6px 12px rgba(48, 38, 59, 0.18));
    }

    .melody-card .spot-name {
      margin: 0.55rem 0 0.15rem;
      font-size: 1.25rem;
      font-weight: 800;
      color: var(--text);
      letter-spacing: 0.01em;
    }

    .melody-card .melody-title {
      font-size: 1rem;
      font-weight: 700;
      color: rgba(48, 38, 59, 0.85);
      margin: 0;
    }

    .melody-card .melody-composer {
      margin: 0.3rem 0 0;
      font-size: 0.85rem;
      color: rgba(48, 38, 59, 0.6);
    }

    .melody-card .spot-description {
      margin-top: 0.85rem;
      font-size: 0.9rem;
      line-height: 1.5;
      color: rgba(48, 38, 59, 0.74);
    }

    .melody-card .progress-track {
      position: absolute;
      left: 18px;
      right: 18px;
      bottom: 16px;
      height: 8px;
      border-radius: 999px;
      background: rgba(255, 255, 255, 0.78);
      overflow: hidden;
      opacity: 0;
      transform: translateY(8px);
      transition: opacity 0.3s ease, transform 0.3s ease;
    }

    .melody-card .progress-bar {
      width: 0%;
      height: 100%;
      background: var(--card-color);
      border-radius: inherit;
    }

    .melody-card[data-active="true"] .progress-track {
      opacity: 1;
      transform: translateY(0);
    }

    .melody-card[data-active="true"] {
      transform: translateY(-6px) scale(1.015);
      box-shadow: 0 28px 52px rgba(157, 107, 255, 0.35);
      border-color: rgba(157, 107, 255, 0.4);
    }

    .melody-card[data-active="true"]::before {
      opacity: 1;
    }

    .melody-card[data-queued="true"] {
      border-color: rgba(157, 107, 255, 0.28);
      box-shadow: 0 20px 40px rgba(48, 38, 59, 0.16);
    }

    .melody-card[data-queued="true"]::after {
      content: 'Next';
      position: absolute;
      top: 12px;
      right: 12px;
      background: rgba(157, 107, 255, 0.18);
      color: var(--text);
      font-size: 0.65rem;
      font-weight: 700;
      letter-spacing: 0.08em;
      text-transform: uppercase;
      padding: 0.3rem 0.55rem;
      border-radius: 999px;
    }

    .melody-card:active {
      transform: translateY(2px) scale(0.99);
    }

    .controls {
      margin-top: 2.7rem;
      position: relative;
      z-index: 1;
      display: flex;
      flex-wrap: wrap;
      justify-content: space-between;
      align-items: center;
      gap: 1.5rem;
      background: rgba(255, 255, 255, 0.92);
      border-radius: 24px;
      padding: 1.3rem 1.6rem;
      box-shadow: 0 16px 34px rgba(48, 38, 59, 0.16);
      border: 2px solid rgba(157, 107, 255, 0.12);
    }

    .volume-control {
      display: flex;
      flex-wrap: wrap;
      align-items: center;
      gap: 0.75rem;
      min-width: 220px;
    }

    .volume-control label {
      font-weight: 700;
      letter-spacing: 0.05em;
      text-transform: uppercase;
      font-size: 0.78rem;
      color: rgba(48, 38, 59, 0.6);
    }

    .volume-control input[type="range"] {
      -webkit-appearance: none;
      appearance: none;
      width: clamp(160px, 25vw, 260px);
      height: 8px;
      border-radius: 999px;
      background: rgba(157, 107, 255, 0.25);
      outline: none;
      position: relative;
    }

    .volume-control input[type="range"]::-webkit-slider-thumb {
      -webkit-appearance: none;
      appearance: none;
      width: 20px;
      height: 20px;
      border-radius: 50%;
      background: var(--accent-4);
      cursor: pointer;
      box-shadow: 0 6px 12px rgba(157, 107, 255, 0.4);
    }

    .volume-control input[type="range"]::-moz-range-thumb {
      width: 20px;
      height: 20px;
      border-radius: 50%;
      background: var(--accent-4);
      cursor: pointer;
      box-shadow: 0 6px 12px rgba(157, 107, 255, 0.4);
      border: none;
    }

    .volume-control__value {
      font-weight: 600;
      font-size: 0.9rem;
      min-width: 3.25rem;
      color: var(--text);
    }

    .stop {
      margin-left: auto;
    }

    .queue-panel {
      margin-top: 2.7rem;
      position: relative;
      z-index: 1;
      background: rgba(255, 255, 255, 0.9);
      border-radius: 26px;
      padding: 1.6rem 1.8rem;
      box-shadow: 0 18px 36px rgba(48, 38, 59, 0.18);
      display: flex;
      flex-direction: column;
      gap: 1rem;
      border: 2px solid rgba(157, 107, 255, 0.15);
    }

    .queue-panel__header {
      display: flex;
      align-items: center;
      justify-content: space-between;
      gap: 1rem;
    }

    .queue-panel h2 {
      margin: 0;
      font-size: 1.25rem;
      color: var(--accent-4);
      letter-spacing: 0.02em;
    }

    .queue-empty {
      margin: 0;
      font-size: 0.95rem;
      color: var(--muted-text);
    }

    .queue-summary {
      margin: 0;
      font-size: 0.9rem;
      color: rgba(48, 38, 59, 0.7);
      display: flex;
      gap: 0.4rem;
      align-items: baseline;
      flex-wrap: wrap;
    }

    .queue-summary__pill {
      display: inline-flex;
      align-items: center;
      justify-content: center;
      padding: 0.2rem 0.75rem;
      border-radius: 999px;
      background: rgba(123, 223, 242, 0.35);
      font-weight: 700;
      letter-spacing: 0.05em;
      text-transform: uppercase;
      font-size: 0.72rem;
      color: var(--text);
    }

    .queue-summary__text {
      font-weight: 600;
      color: var(--text);
    }

    .queue-list {
      list-style: none;
      margin: 0;
      padding: 0;
      display: flex;
      flex-direction: column;
      gap: 0.6rem;
    }

    .queue-item {
      display: flex;
      align-items: center;
      gap: 0.65rem;
      font-size: 0.95rem;
      color: rgba(48, 38, 59, 0.9);
    }

    .queue-item .queue-pill {
      display: inline-flex;
      align-items: center;
      justify-content: center;
      background: rgba(157, 107, 255, 0.16);
      color: var(--text);
      border-radius: 999px;
      padding: 0.35rem 0.85rem;
      font-weight: 700;
      letter-spacing: 0.02em;
    }

    .queue-item .queue-meta {
      font-size: 0.8rem;
      text-transform: uppercase;
      letter-spacing: 0.08em;
      color: rgba(48, 38, 59, 0.55);
    }

    .queue-item.queue-item--more {
      justify-content: flex-end;
      font-style: italic;
      color: rgba(48, 38, 59, 0.55);
    }

    .queue-item.is-playing .queue-pill {
      background: rgba(123, 223, 242, 0.45);
      color: var(--accent-4);
    }

    .queue-item.is-next .queue-pill {
      background: rgba(255, 169, 77, 0.45);
      color: var(--accent-2);
    }

    button.clear-queue {
      background: rgba(255, 255, 255, 0.8);
      border: 2px solid rgba(157, 107, 255, 0.35);
      color: var(--text);
      font-weight: 700;
      border-radius: 999px;
      padding: 0.55rem 1.25rem;
      cursor: pointer;
      transition: border-color 0.2s ease, transform 0.2s ease, box-shadow 0.2s ease;
      box-shadow: 0 8px 16px rgba(157, 107, 255, 0.18);
    }

    button.clear-queue:hover:not(:disabled) {
      border-color: rgba(157, 107, 255, 0.6);
      transform: translateY(-2px);
      box-shadow: 0 12px 20px rgba(157, 107, 255, 0.25);
    }

    button.clear-queue:disabled {
      cursor: not-allowed;
      opacity: 0.55;
      box-shadow: none;
    }

    button.stop {
      background: linear-gradient(120deg, var(--accent-1), var(--accent-4));
      color: #fff;
      font-weight: 800;
      font-size: 1.05rem;
      border: none;
      border-radius: 999px;
      padding: 0.95rem 2.6rem;
      cursor: pointer;
      box-shadow: 0 18px 32px rgba(255, 138, 160, 0.35);
      transition: transform 0.25s ease, box-shadow 0.25s ease, filter 0.25s ease;
    }

    button.stop:hover {
      transform: translateY(-4px);
      box-shadow: 0 22px 38px rgba(255, 138, 160, 0.4);
      filter: brightness(1.05);
    }

    button.stop:active {
      transform: translateY(0);
    }

    footer {
      margin-top: 2.2rem;
      text-align: center;
      font-size: 0.9rem;
      color: rgba(48, 38, 59, 0.65);
      position: relative;
      z-index: 1;
    }

    .melody-toast {
      position: fixed;
      bottom: 32px;
      right: 32px;
      z-index: 5;
      pointer-events: none;
      opacity: 0;
      transform: translateY(16px);
      transition: opacity 0.25s ease, transform 0.25s ease;
      max-width: min(320px, calc(100vw - 40px));
    }

    .melody-toast[data-visible="true"] {
      opacity: 1;
      transform: translateY(0);
    }

    .melody-toast__bubble {
      display: flex;
      align-items: center;
      gap: 0.85rem;
      background: rgba(255, 255, 255, 0.95);
      border-radius: 26px;
      padding: 0.8rem 1.2rem;
      box-shadow: 0 20px 44px rgba(157, 107, 255, 0.28);
      border: 2px solid rgba(157, 107, 255, 0.3);
      backdrop-filter: blur(10px);
    }

    .melody-toast__key {
      display: inline-flex;
      align-items: center;
      justify-content: center;
      min-width: 50px;
      min-height: 50px;
      padding: 0 0.75rem;
      border-radius: 16px;
      background: var(--toast-accent);
      color: #fff;
      font-weight: 800;
      font-size: 1.4rem;
      letter-spacing: 0.04em;
      white-space: nowrap;
      text-align: center;
      box-shadow: inset 0 -4px 10px rgba(48, 38, 59, 0.18);
    }

    .melody-toast__text {
      display: flex;
      flex-direction: column;
      gap: 0.2rem;
    }

    .melody-toast__title {
      font-weight: 700;
      font-size: 1.05rem;
      color: var(--text);
      line-height: 1.2;
    }

    .melody-toast__composer {
      font-size: 0.85rem;
      letter-spacing: 0.04em;
      text-transform: uppercase;
      color: rgba(48, 38, 59, 0.55);
    }

    @media (max-width: 600px) {
      main {
        padding: 2rem 1.4rem;
      }

      .keys-grid {
        gap: 1.2rem;
        grid-template-columns: repeat(auto-fit, minmax(180px, 1fr));
      }

      .melody-card {
        padding: 1.35rem 1.05rem 1.95rem;
      }

      .now-playing {
        padding: 0.8rem 1.05rem;
        font-size: 0.95rem;
      }

      .melody-card .spot-icon {
        font-size: 1.9rem;
      }

      .queue-panel {
        padding: 1.3rem 1.35rem;
      }

      .queue-panel__header {
        flex-direction: column;
        align-items: flex-start;
        gap: 0.75rem;
      }

      .melody-toast {
        left: 20px;
        right: 20px;
        bottom: 24px;
        max-width: none;
      }

      .melody-toast__bubble {
        justify-content: center;
        text-align: center;
      }

      .melody-toast__key {
        min-width: 46px;
        min-height: 46px;
        font-size: 1.2rem;
      }
    }
  </style>
</head>
<body>
  <main>
    <header>
      <h1>Keyboard Kids</h1>
      <p class="lead">Pick a playful music spot, queue up a few favourites, and let each button burst into a kid-sized classical melody.</p>
      <div class="now-playing" role="status" aria-live="polite">
        <span class="label">Now playing</span>
        <span class="value">Tap a colorful music spot to start the concert!</span>
      </div>
    </header>

    <div class="melody-toast" role="status" aria-live="assertive" aria-atomic="true">
      <div class="melody-toast__bubble">
        <span class="melody-toast__key" aria-hidden="true"></span>
        <div class="melody-toast__text">
          <span class="melody-toast__title"></span>
          <span class="melody-toast__composer"></span>
        </div>
      </div>
    </div>

    <section class="keys-grid" aria-label="Melody play spots"></section>

    <aside class="queue-panel" aria-label="Playback queue" aria-live="polite">
      <div class="queue-panel__header">
        <h2>Playback queue</h2>
        <button class="clear-queue" type="button" id="clearQueueButton" disabled>Clear queue</button>
      </div>
      <p class="queue-empty" id="queueEmptyMessage">No melodies queued yet—tap a music spot to line one up.</p>
      <p class="queue-summary" id="queueSummary" hidden>
        <span class="queue-summary__pill" id="queueCount"></span>
        <span class="queue-summary__text" id="queueDuration"></span>
      </p>
      <ol class="queue-list" role="list" aria-describedby="queueEmptyMessage"></ol>
    </aside>

    <div class="controls">
      <div class="volume-control">
        <label for="volumeSlider">Volume</label>
        <input type="range" id="volumeSlider" min="0" max="100" value="68" step="1" aria-label="Volume level" />
        <span class="volume-control__value" id="volumeValue" aria-live="polite">68%</span>
      </div>
      <button class="stop" type="button" id="stopButton">Stop the music</button>
    </div>

    <footer>
      Tip: Pair up and try patterns together—the queue keeps every melody waiting its turn with a smile.
    </footer>
  </main>

  <script>
    const NOTE_FREQUENCIES = {
      'C3': 130.81,
      'D3': 146.83,
      'E3': 164.81,
      'F3': 174.61,
      'G3': 196.0,
      'A3': 220.0,
      'Bb3': 233.08,
      'B3': 246.94,
      'C4': 261.63,
      'Cs4': 277.18,
      'D4': 293.66,
      'Ds4': 311.13,
      'E4': 329.63,
      'F4': 349.23,
      'Fs4': 369.99,
      'G4': 392.0,
      'Gs4': 415.3,
      'A4': 440.0,
      'As4': 466.16,
      'B4': 493.88,
      'C5': 523.25,
      'Cs5': 554.37,
      'D5': 587.33,
      'Ds5': 622.25,
      'E5': 659.26,
      'F5': 698.46,
      'Fs5': 739.99,
      'G5': 783.99,
      'Gs5': 830.61,
      'A5': 880.0,
      'B5': 987.77,
      'C6': 1046.5
    };

    const PATTERN_LIBRARY = {
      ode: {
        title: 'Ode to Joy',
        composer: 'L. v. Beethoven',
        notes: [
          { note: 'E4', duration: 420 },
          { note: 'E4', duration: 420 },
          { note: 'F4', duration: 420 },
          { note: 'G4', duration: 620 },
          { note: 'G4', duration: 420 },
          { note: 'F4', duration: 420 },
          { note: 'E4', duration: 420 },
          { note: 'D4', duration: 620 },
          { note: 'C4', duration: 420 },
          { note: 'C4', duration: 420 },
          { note: 'D4', duration: 420 },
          { note: 'E4', duration: 620 },
          { note: 'E4', duration: 420 },
          { note: 'D4', duration: 420 },
          { note: 'D4', duration: 840 }
        ]
      },
      mozart: {
        title: 'Eine Kleine Nachtmusik',
        composer: 'W. A. Mozart',
        notes: [
          { note: 'G4', duration: 420 },
          { note: 'G4', duration: 420 },
          { note: 'D4', duration: 420 },
          { note: 'E4', duration: 420 },
          { note: 'F4', duration: 420 },
          { note: 'F4', duration: 420 },
          { note: 'E4', duration: 420 },
          { note: 'D4', duration: 420 },
          { note: 'C4', duration: 420 },
          { note: 'E4', duration: 420 },
          { note: 'G4', duration: 840 },
          { note: 'G4', duration: 420 },
          { note: 'F4', duration: 420 },
          { note: 'E4', duration: 420 },
          { note: 'D4', duration: 840 }
        ]
      },
      minuet: {
        title: 'Minuet in G',
        composer: 'J. S. Bach',
        notes: [
          { note: 'G4', duration: 420 },
          { note: 'A4', duration: 420 },
          { note: 'B4', duration: 420 },
          { note: 'C5', duration: 420 },
          { note: 'D5', duration: 840 },
          { note: 'B4', duration: 420 },
          { note: 'C5', duration: 420 },
          { note: 'D5', duration: 420 },
          { note: 'E5', duration: 420 },
          { note: 'C5', duration: 840 },
          { note: 'A4', duration: 420 },
          { note: 'B4', duration: 420 },
          { note: 'C5', duration: 420 },
          { note: 'D5', duration: 420 },
          { note: 'B4', duration: 840 }
        ]
      },
      canon: {
        title: 'Canon in D',
        composer: 'J. Pachelbel',
        notes: [
          { note: 'Fs4', duration: 420 },
          { note: 'E4', duration: 420 },
          { note: 'Ds4', duration: 420 },
          { note: 'Cs4', duration: 420 },
          { note: 'B3', duration: 420 },
          { note: 'Cs4', duration: 420 },
          { note: 'Ds4', duration: 420 },
          { note: 'E4', duration: 420 },
          { note: 'Fs4', duration: 420 },
          { note: 'E4', duration: 420 },
          { note: 'Ds4', duration: 420 },
          { note: 'Cs4', duration: 420 },
          { note: 'B3', duration: 420 },
          { note: 'Cs4', duration: 420 },
          { note: 'Ds4', duration: 840 }
        ]
      },
      sugarPlum: {
        title: 'Dance of the Sugar Plum Fairy',
        composer: 'P. I. Tchaikovsky',
        notes: [
          { note: 'G4', duration: 420 },
          { note: 'REST', duration: 210 },
          { note: 'G4', duration: 420 },
          { note: 'REST', duration: 210 },
          { note: 'G4', duration: 420 },
          { note: 'Ds5', duration: 420 },
          { note: 'Gs4', duration: 420 },
          { note: 'G4', duration: 420 },
          { note: 'Ds5', duration: 420 },
          { note: 'Gs4', duration: 420 },
          { note: 'G4', duration: 420 },
          { note: 'Ds5', duration: 420 },
          { note: 'Gs4', duration: 420 },
          { note: 'G4', duration: 420 },
          { note: 'Ds5', duration: 840 }
        ]
      },
      morning: {
        title: 'Morning Mood',
        composer: 'E. Grieg',
        notes: [
          { note: 'E4', duration: 420 },
          { note: 'G4', duration: 420 },
          { note: 'A4', duration: 420 },
          { note: 'B4', duration: 420 },
          { note: 'C5', duration: 840 },
          { note: 'B4', duration: 420 },
          { note: 'A4', duration: 420 },
          { note: 'G4', duration: 420 },
          { note: 'E4', duration: 420 },
          { note: 'G4', duration: 420 },
          { note: 'A4', duration: 420 },
          { note: 'B4', duration: 420 },
          { note: 'C5', duration: 840 },
          { note: 'B4', duration: 420 },
          { note: 'A4', duration: 840 }
        ]
      },
      twinkle: {
        title: 'Twinkle, Twinkle Little Star',
        composer: 'W. A. Mozart',
        notes: [
          { note: 'C4', duration: 420 },
          { note: 'C4', duration: 420 },
          { note: 'G4', duration: 420 },
          { note: 'G4', duration: 420 },
          { note: 'A4', duration: 420 },
          { note: 'A4', duration: 420 },
          { note: 'G4', duration: 840 },
          { note: 'F4', duration: 420 },
          { note: 'F4', duration: 420 },
          { note: 'E4', duration: 420 },
          { note: 'E4', duration: 420 },
          { note: 'D4', duration: 420 },
          { note: 'D4', duration: 420 },
          { note: 'C4', duration: 840 }
        ]
      },
      clair: {
        title: 'Clair de Lune',
        composer: 'C. Debussy',
        notes: [
          { note: 'D4', duration: 420 },
          { note: 'Fs4', duration: 420 },
          { note: 'A4', duration: 620 },
          { note: 'D5', duration: 420 },
          { note: 'Cs5', duration: 420 },
          { note: 'A4', duration: 620 },
          { note: 'Fs4', duration: 420 },
          { note: 'D4', duration: 840 }
        ]
      },
      swan: {
        title: 'Swan Lake',
        composer: 'P. I. Tchaikovsky',
        notes: [
          { note: 'A4', duration: 420 },
          { note: 'E5', duration: 420 },
          { note: 'F5', duration: 420 },
          { note: 'E5', duration: 420 },
          { note: 'D5', duration: 420 },
          { note: 'B4', duration: 420 },
          { note: 'A4', duration: 420 },
          { note: 'Fs4', duration: 420 },
          { note: 'E4', duration: 840 }
        ]
      },
      blueDanube: {
        title: 'The Blue Danube',
        composer: 'J. Strauss II',
        notes: [
          { note: 'D4', duration: 420 },
          { note: 'Fs4', duration: 420 },
          { note: 'A4', duration: 420 },
          { note: 'D5', duration: 620 },
          { note: 'A4', duration: 420 },
          { note: 'Fs4', duration: 420 },
          { note: 'D4', duration: 620 },
          { note: 'Fs4', duration: 420 },
          { note: 'A4', duration: 420 },
          { note: 'D5', duration: 840 }
        ]
      },
      spring: {
        title: 'Spring',
        composer: 'A. Vivaldi',
        notes: [
          { note: 'E5', duration: 420 },
          { note: 'E5', duration: 420 },
          { note: 'E5', duration: 420 },
          { note: 'C5', duration: 420 },
          { note: 'E5', duration: 420 },
          { note: 'Fs5', duration: 420 },
          { note: 'G5', duration: 840 },
          { note: 'E5', duration: 420 },
          { note: 'C5', duration: 420 },
          { note: 'E5', duration: 420 },
          { note: 'G5', duration: 840 }
        ]
      },
      gymno: {
        title: 'Gymnopédie No. 1',
        composer: 'E. Satie',
        notes: [
          { note: 'D4', duration: 420 },
          { note: 'A4', duration: 620 },
          { note: 'Fs4', duration: 420 },
          { note: 'D4', duration: 420 },
          { note: 'G4', duration: 420 },
          { note: 'B4', duration: 620 },
          { note: 'A4', duration: 420 },
          { note: 'Fs4', duration: 840 }
        ]
      },
      lullaby: {
        title: "Brahms' Lullaby",
        composer: 'J. Brahms',
        notes: [
          { note: 'G4', duration: 420 },
          { note: 'E4', duration: 420 },
          { note: 'G4', duration: 420 },
          { note: 'E4', duration: 420 },
          { note: 'G4', duration: 420 },
          { note: 'B4', duration: 420 },
          { note: 'A4', duration: 840 },
          { note: 'A4', duration: 420 },
          { note: 'Fs4', duration: 420 },
          { note: 'A4', duration: 420 },
          { note: 'Fs4', duration: 420 },
          { note: 'A4', duration: 420 },
          { note: 'D5', duration: 420 },
          { note: 'B4', duration: 840 }
        ]
      }
    };

    const PLAY_SPOTS = [
      {
        id: 'sunny-meadow',
        name: 'Sunny Meadow',
        description: "Bounce along with Beethoven's happiest tune.",
        patternId: 'ode',
        icon: '🌻',
        color: 'var(--accent-5)'
      },
      {
        id: 'starlight-stage',
        name: 'Starlight Stage',
        description: 'Mozart sprinkles twinkly notes across the sky.',
        patternId: 'mozart',
        icon: '🌟',
        color: 'var(--accent-4)'
      },
      {
        id: 'moonlit-lagoon',
        name: 'Moonlit Lagoon',
        description: 'Dreamy ripples from Debussy shimmer on the water.',
        patternId: 'clair',
        icon: '🌙',
        color: 'var(--accent-3)'
      },
      {
        id: 'swan-pond',
        name: 'Swan Pond',
        description: 'Glide with Tchaikovsky through gentle waltz waves.',
        patternId: 'swan',
        icon: '🦢',
        color: 'var(--accent-6)'
      },
      {
        id: 'spring-garden',
        name: 'Spring Garden',
        description: "Vivaldi's violins bloom in a swirl of petals.",
        patternId: 'spring',
        icon: '🌼',
        color: 'var(--accent-2)'
      },
      {
        id: 'dreamy-nook',
        name: 'Dreamy Nook',
        description: 'Snuggle in for Brahms’ gentle lullaby.',
        patternId: 'lullaby',
        icon: '💤',
        color: 'var(--accent-7)'
      }
    ];

    const melodies = {};
    const keysGrid = document.querySelector('.keys-grid');
    const nowPlayingValue = document.querySelector('.now-playing .value');
    const queueList = document.querySelector('.queue-list');
    const queueEmptyMessage = document.getElementById('queueEmptyMessage');
    const queueSummary = document.getElementById('queueSummary');
    const queueCount = document.getElementById('queueCount');
    const queueDuration = document.getElementById('queueDuration');
    const clearQueueButton = document.getElementById('clearQueueButton');
    const melodyToast = document.querySelector('.melody-toast');
    const melodyToastKey = melodyToast ? melodyToast.querySelector('.melody-toast__key') : null;
    const melodyToastTitle = melodyToast ? melodyToast.querySelector('.melody-toast__title') : null;
    const melodyToastComposer = melodyToast ? melodyToast.querySelector('.melody-toast__composer') : null;
    const volumeSlider = document.getElementById('volumeSlider');
    const volumeValue = document.getElementById('volumeValue');
    const stopButton = document.getElementById('stopButton');
    const STORAGE_KEYS = {
      volume: 'keyboardKids.volumeLevel'
    };

    if (keysGrid) {
      PLAY_SPOTS.forEach((spot, index) => {
        const pattern = PATTERN_LIBRARY[spot.patternId];
        if (!pattern) {
          return;
        }

        const fallbackAccentIndex = (index % 6) + 1;
        const color = spot.color || `var(--accent-${fallbackAccentIndex})`;
        const icon = spot.icon || '🎵';

        melodies[spot.id] = {
          title: pattern.title,
          composer: pattern.composer,
          keyLabel: spot.name,
          notes: pattern.notes
        };

        const card = document.createElement('article');
        card.className = 'melody-card';
        card.dataset.key = spot.id;
        card.dataset.color = color;
        card.style.setProperty('--card-color', color);
        card.innerHTML = `
          <span class="spot-icon" aria-hidden="true">${icon}</span>
          <h3 class="spot-name">${spot.name}</h3>
          <p class="melody-title">${pattern.title}</p>
          <p class="melody-composer">${pattern.composer}</p>
          ${spot.description ? `<p class="spot-description">${spot.description}</p>` : ''}
          <div class="progress-track" aria-hidden="true">
            <div class="progress-bar"></div>
          </div>
        `;
        card.setAttribute('title', `${spot.name} plays ${pattern.title}`);
        card.setAttribute('aria-label', `${spot.name} plays ${pattern.title}`);
        card.setAttribute('role', 'button');
        card.setAttribute('tabindex', '0');

        const activate = () => enqueueMelody(spot.id);

        card.addEventListener('click', activate);
        card.addEventListener('keydown', (event) => {
          if (event.key === 'Enter' || event.key === ' ') {
            event.preventDefault();
            event.stopPropagation();
            activate();
          }
        });

        keysGrid.appendChild(card);
      });
    }

    const audioContext = new (window.AudioContext || window.webkitAudioContext)();
    const masterGain = audioContext.createGain();
    masterGain.connect(audioContext.destination);

    const playbackQueue = [];
    let isProcessingQueue = false;
    let cancelCurrent = false;
    let activeNodes = [];
    let currentCard = null;
    let currentDurationEstimate = 0;
    let toastHideTimeout = null;

    function hideMelodyToast(clearTimer = false) {
      if (!melodyToast) {
        return;
      }
      if (clearTimer && toastHideTimeout) {
        clearTimeout(toastHideTimeout);
        toastHideTimeout = null;
      }
      delete melodyToast.dataset.visible;
    }

    function showMelodyToast(key) {
      if (!melodyToast) {
        return;
      }
      const melody = melodies[key];
      if (!melody) {
        return;
      }
      if (toastHideTimeout) {
        clearTimeout(toastHideTimeout);
        toastHideTimeout = null;
      }

      if (melodyToastKey) {
        const label = melody.keyLabel || key;
        const trimmed = label.length > 18 ? `${label.slice(0, 17)}…` : label;
        melodyToastKey.textContent = trimmed;
      }

      if (melodyToastTitle) {
        melodyToastTitle.textContent = melody.title || '';
      }

      if (melodyToastComposer) {
        if (melody.composer) {
          melodyToastComposer.textContent = `by ${melody.composer}`;
          melodyToastComposer.style.display = '';
        } else {
          melodyToastComposer.textContent = '';
          melodyToastComposer.style.display = 'none';
        }
      }

      const card = document.querySelector(`.melody-card[data-key="${key}"]`);
      if (card && card.dataset && card.dataset.color) {
        const accent = card.dataset.color;
        melodyToast.style.setProperty('--toast-accent', accent);
      } else {
        melodyToast.style.setProperty('--toast-accent', 'var(--accent-4)');
      }

      melodyToast.dataset.visible = 'true';
      toastHideTimeout = setTimeout(() => {
        toastHideTimeout = null;
        hideMelodyToast();
      }, 2600);
    }

    function syncQueueButtonState() {
      if (!clearQueueButton) {
        return;
      }
      clearQueueButton.disabled = playbackQueue.length === 0;
    }

    function renderQueue() {
      if (!queueList) {
        syncQueueButtonState();
        return;
      }

      queueList.innerHTML = '';

      const activeKey = currentCard && currentCard.dataset ? currentCard.dataset.key : null;
      const activeMelody = activeKey ? melodies[activeKey] : null;

      if (activeMelody) {
        const item = document.createElement('li');
        item.className = 'queue-item is-playing';
        item.innerHTML = `
          <span class="queue-pill">${activeMelody.title}</span>
          <span class="queue-meta">Now playing</span>
        `;
        queueList.appendChild(item);
      }

      const previewCount = 6;
      const upcoming = playbackQueue.slice(0, previewCount);
      upcoming.forEach((key, index) => {
        const melody = melodies[key];
        if (!melody) {
          return;
        }
        const item = document.createElement('li');
        item.className = 'queue-item';
        if (index === 0) {
          item.classList.add('is-next');
        }
        const label = index === 0 ? 'Next up' : `In line #${index + 1}`;
        item.innerHTML = `
          <span class="queue-pill">${melody.title}</span>
          <span class="queue-meta">${label}</span>
        `;
        queueList.appendChild(item);
      });

      if (playbackQueue.length > upcoming.length) {
        const remaining = playbackQueue.length - upcoming.length;
        const item = document.createElement('li');
        item.className = 'queue-item queue-item--more';
        item.innerHTML = `<span class="queue-meta">+ ${remaining} more queued</span>`;
        queueList.appendChild(item);
      }

      const hasEntries = queueList.children.length > 0;
      if (queueEmptyMessage) {
        queueEmptyMessage.hidden = hasEntries;
      }
      queueList.hidden = !hasEntries;

      const queuedMelodies = playbackQueue.filter((key) => melodies[key]);
      const totalItems = (activeMelody ? 1 : 0) + queuedMelodies.length;
      const upcomingDuration = queuedMelodies.reduce((total, key) => {
        const melody = melodies[key];
        return melody ? total + totalDurationForMelody(melody) : total;
      }, 0);
      const activeDuration = activeMelody ? currentDurationEstimate : 0;
      const totalDuration = activeDuration + upcomingDuration;

      if (queueSummary) {
        if (totalItems > 0) {
          queueSummary.hidden = false;
          if (queueCount) {
            queueCount.textContent = totalItems === 1 ? '1 melody' : `${totalItems} melodies`;
          }
          if (queueDuration) {
            queueDuration.textContent = totalDuration > 0
              ? `Approx. ${formatDuration(totalDuration)}`
              : 'Approx. 0s';
          }
        } else {
          queueSummary.hidden = true;
        }
      }

      syncQueueButtonState();
    }

    function totalDurationForMelody(melody) {
      if (!melody || !Array.isArray(melody.notes)) {
        return 0;
      }
      const base = melody.notes.reduce((total, segment) => {
        const duration = typeof segment.duration === 'number' ? segment.duration : 0;
        return total + Math.max(duration, 0);
      }, 0);
      const padding = melody.notes.length * 60;
      return base + padding;
    }

    function formatDuration(durationMs) {
      if (!durationMs || !Number.isFinite(durationMs)) {
        return '0s';
      }
      const totalSeconds = Math.max(Math.round(durationMs / 1000), 0);
      const minutes = Math.floor(totalSeconds / 60);
      const seconds = totalSeconds % 60;
      if (minutes <= 0) {
        return `${seconds}s`;
      }
      return `${minutes}m ${seconds.toString().padStart(2, '0')}s`;
    }

    function clamp(value, min, max) {
      return Math.min(Math.max(value, min), max);
    }

    function sliderValueToGain(value) {
      const normalized = clamp(Number(value) / 100, 0, 1);
      const curved = Math.pow(normalized, 1.5);
      return +(curved * 0.9).toFixed(4);
    }

    function paintVolumeSlider(value) {
      if (!volumeSlider) {
        return;
      }
      const percent = clamp(Number(value), 0, 100);
      const fill = `${percent}%`;
      volumeSlider.style.background = `linear-gradient(90deg, var(--accent-4) ${fill}, rgba(106, 76, 147, 0.24) ${fill})`;
    }

    function updateVolumeDisplay(value) {
      const rounded = Math.round(clamp(Number(value), 0, 100));
      if (volumeValue) {
        volumeValue.textContent = `${rounded}%`;
      }
      if (volumeSlider) {
        volumeSlider.setAttribute('aria-valuenow', String(rounded));
        volumeSlider.setAttribute('aria-valuetext', `${rounded} percent volume`);
      }
    }

    function applyVolume(value, { persist = false } = {}) {
      const numericValue = clamp(Number(value), 0, 100);
      const gainValue = sliderValueToGain(numericValue);
      masterGain.gain.setTargetAtTime(gainValue, audioContext.currentTime, 0.01);
      updateVolumeDisplay(numericValue);
      paintVolumeSlider(numericValue);
      if (persist && window.localStorage) {
        try {
          window.localStorage.setItem(STORAGE_KEYS.volume, String(numericValue));
        } catch (err) {
          /* ignore storage errors */
        }
      }
    }

    function readStoredVolume() {
      if (!window.localStorage) {
        return null;
      }
      try {
        const stored = window.localStorage.getItem(STORAGE_KEYS.volume);
        if (stored === null) {
          return null;
        }
        const parsed = Number.parseFloat(stored);
        return Number.isNaN(parsed) ? null : clamp(parsed, 0, 100);
      } catch (err) {
        return null;
      }
    }

    function startProgress(card, durationMs) {
      if (!card) {
        return;
      }
      const bar = card.querySelector('.progress-bar');
      if (!bar) {
        return;
      }
      const safeDuration = Math.max(durationMs || 0, 400);
      bar.style.transition = 'none';
      bar.style.width = '0%';
      requestAnimationFrame(() => {
        bar.style.transition = `width ${safeDuration}ms linear`;
        bar.style.width = '100%';
      });
    }

    function clearProgress(card) {
      if (!card) {
        return;
      }
      const bar = card.querySelector('.progress-bar');
      if (!bar) {
        return;
      }
      requestAnimationFrame(() => {
        bar.style.transition = 'width 220ms ease';
        bar.style.width = '0%';
      });
    }

    function describeMelody(key) {
      const melody = melodies[key];
      if (!melody) {
        return null;
      }
      return `${melody.title} — ${melody.composer} (${melody.keyLabel})`;
    }

    function refreshNowPlayingStatus() {
      if (!nowPlayingValue) {
        return;
      }
      if (currentCard && currentCard.dataset && currentCard.dataset.key) {
        const description = describeMelody(currentCard.dataset.key);
        if (description) {
          nowPlayingValue.textContent = description;
          return;
        }
      }
      if (playbackQueue.length > 0) {
        const nextDescription = describeMelody(playbackQueue[0]);
        if (nextDescription) {
          nowPlayingValue.textContent = `Queued: ${nextDescription}`;
          return;
        }
      }
      nowPlayingValue.textContent = 'Tap a music spot to begin!';
    }

    function wait(ms) {
      return new Promise(resolve => setTimeout(resolve, ms));
    }

    function updateQueueIndicators() {
      const cards = document.querySelectorAll('.melody-card');
      const queuedSet = new Set(playbackQueue);
      const currentKey = currentCard ? currentCard.dataset.key : null;
      cards.forEach((card) => {
        if (queuedSet.has(card.dataset.key) && card.dataset.key !== currentKey) {
          card.dataset.queued = 'true';
        } else {
          delete card.dataset.queued;
        }
      });
      refreshNowPlayingStatus();
      renderQueue();
    }

    function setActiveCard(key, totalDuration) {
      unsetActiveCard();
      const card = document.querySelector(`.melody-card[data-key="${key}"]`);
      if (card) {
        currentCard = card;
        currentDurationEstimate = typeof totalDuration === 'number' ? totalDuration : 0;
        card.dataset.active = 'true';
        delete card.dataset.queued;
        if (typeof totalDuration === 'number' && totalDuration > 0) {
          startProgress(card, totalDuration);
        }
        refreshNowPlayingStatus();
        renderQueue();
      }
    }

    function unsetActiveCard() {
      if (currentCard) {
        const previous = currentCard;
        previous.dataset.active = 'false';
        clearProgress(previous);
        currentCard = null;
        currentDurationEstimate = 0;
        updateQueueIndicators();
      }
    }

    async function playSegment(segment) {
      if (cancelCurrent) {
        return;
      }

      const durationMs = typeof segment.duration === 'number' ? segment.duration : 0;
      const frequency = NOTE_FREQUENCIES[segment.note];
      if (!frequency) {
        await wait(durationMs);
        return;
      }

      const now = audioContext.currentTime;
      const oscillator = audioContext.createOscillator();
      const overtone = audioContext.createOscillator();
      const vibrato = audioContext.createOscillator();
      const gainNode = audioContext.createGain();
      const overtoneGain = audioContext.createGain();
      const vibratoGain = audioContext.createGain();

      oscillator.type = 'triangle';
      oscillator.frequency.setValueAtTime(frequency, now);

      overtone.type = 'sine';
      overtone.frequency.setValueAtTime(frequency * 2, now);
      overtoneGain.gain.value = 0.18;

      vibrato.type = 'sine';
      vibrato.frequency.value = 5.5;
      vibratoGain.gain.value = Math.max(frequency * 0.008, 1.5);

      oscillator.connect(gainNode);
      overtone.connect(overtoneGain);
      overtoneGain.connect(gainNode);
      vibrato.connect(vibratoGain);
      vibratoGain.connect(oscillator.frequency);
      gainNode.connect(masterGain);

      const totalSeconds = Math.max(durationMs / 1000, 0.12);
      const attack = Math.min(0.09, totalSeconds * 0.3);
      const decay = Math.min(0.1, totalSeconds * 0.2);
      const sustainLevel = 0.42;
      const release = Math.min(0.2, totalSeconds * 0.35);
      const sustain = Math.max(totalSeconds - attack - decay - release, 0.02);

      gainNode.gain.cancelScheduledValues(now);
      gainNode.gain.setValueAtTime(0.0001, now);
      gainNode.gain.exponentialRampToValueAtTime(0.9, now + attack);
      gainNode.gain.setTargetAtTime(sustainLevel, now + attack, decay);
      gainNode.gain.setTargetAtTime(0.0001, now + attack + sustain, release);

      oscillator.start(now);
      overtone.start(now);
      vibrato.start(now);

      const nodeGroup = { gainNode, oscillators: [oscillator, overtone, vibrato] };
      activeNodes.push(nodeGroup);

      await wait(Math.max(durationMs - 40, 10));
      if (!cancelCurrent) {
        gainNode.gain.exponentialRampToValueAtTime(0.0001, audioContext.currentTime + 0.05);
        await wait(60);
      }

      nodeGroup.oscillators.forEach((node) => {
        try {
          node.stop();
        } catch (err) {
          /* oscillator may already be stopped */
        }
        try {
          node.disconnect();
        } catch (err) {
          /* ignore */
        }
      });
      [gainNode, overtoneGain, vibratoGain].forEach((node) => {
        try {
          node.disconnect();
        } catch (err) {
          /* ignore */
        }
      });

      activeNodes = activeNodes.filter((entry) => entry !== nodeGroup);
    }

    async function runMelody(key) {
      const melody = melodies[key];
      if (!melody) {
        return;
      }

      await audioContext.resume();
      const totalDuration = totalDurationForMelody(melody);
      setActiveCard(key, totalDuration);

      for (const segment of melody.notes) {
        if (cancelCurrent) {
          break;
        }
        await playSegment(segment);
      }

      if (!cancelCurrent) {
        await wait(140);
        unsetActiveCard();
      }
      refreshNowPlayingStatus();
    }

    async function processQueue() {
      if (isProcessingQueue) {
        return;
      }
      isProcessingQueue = true;
      try {
        while (playbackQueue.length > 0) {
          if (cancelCurrent) {
            playbackQueue.length = 0;
            break;
          }
          const nextKey = playbackQueue.shift();
          updateQueueIndicators();
          await runMelody(nextKey);
        }
      } finally {
        isProcessingQueue = false;
        if (!cancelCurrent) {
          unsetActiveCard();
        }
        cancelCurrent = false;
        updateQueueIndicators();
      }
    }

    function enqueueMelody(key) {
      if (!melodies[key]) {
        return;
      }
      showMelodyToast(key);
      playbackQueue.push(key);
      updateQueueIndicators();
      if (!isProcessingQueue) {
        cancelCurrent = false;
        processQueue();
      }
    }

    function stopPlayback() {
      if (!isProcessingQueue && activeNodes.length === 0) {
        return;
      }
      cancelCurrent = true;
      playbackQueue.length = 0;
      updateQueueIndicators();
      const now = audioContext.currentTime;
      activeNodes.forEach(({ gainNode, oscillators }) => {
        try {
          gainNode.gain.cancelScheduledValues(now);
          gainNode.gain.setTargetAtTime(0.0001, now, 0.05);
        } catch (err) {
          /* ignore */
        }
        oscillators.forEach((node) => {
          try {
            node.stop(now + 0.05);
          } catch (err) {
            /* ignore */
          }
        });
      });
      activeNodes = [];
      unsetActiveCard();
      hideMelodyToast(true);
    }

    if (stopButton) {
      stopButton.addEventListener('click', () => {
        stopPlayback();
      });
    }

    if (clearQueueButton) {
      clearQueueButton.addEventListener('click', () => {
        if (playbackQueue.length === 0) {
          return;
        }
        playbackQueue.length = 0;
        updateQueueIndicators();
      });
    }

    refreshNowPlayingStatus();
    renderQueue();

    const initialVolume = (() => {
      const stored = readStoredVolume();
      if (stored !== null) {
        return stored;
      }
      if (volumeSlider && typeof volumeSlider.value === 'string') {
        const parsed = Number.parseFloat(volumeSlider.value);
        if (!Number.isNaN(parsed)) {
          return clamp(parsed, 0, 100);
        }
      }
      return 68;
    })();

    applyVolume(initialVolume);
    if (volumeSlider) {
      volumeSlider.value = String(initialVolume);
      paintVolumeSlider(initialVolume);
      volumeSlider.addEventListener('input', () => {
        applyVolume(volumeSlider.value);
      });
      ['change', 'blur'].forEach((eventName) => {
        volumeSlider.addEventListener(eventName, () => {
          applyVolume(volumeSlider.value, { persist: true });
        });
      });
    }

    setTimeout(() => {
      const cards = document.querySelectorAll('.melody-card');
      cards.forEach((card, index) => {
        setTimeout(() => {
          card.dataset.active = 'true';
          setTimeout(() => {
            if (card !== currentCard) {
              card.dataset.active = 'false';
            }
          }, 320);
        }, index * 60);
      });
    }, 300);
  </script>
</body>
</html>
